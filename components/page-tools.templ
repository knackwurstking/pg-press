package components

import (
	"fmt"
	"github.com/knackwurstking/pgpress/env"
	"github.com/knackwurstking/pgpress/models"
	"github.com/knackwurstking/pgpress/utils"
	"time"
)

const (
	PageTools_IDToolsFilter = "tools-filter"
)

templ PageTools() {
	@Layout(
		LayoutOptions{
			PageTitle:   "PG Presse | Werkzeuge",
			AppBarTitle: "Werkzeuge",
			NavContent:  StandardNavContent(),
		},
	) {
		<main class="container fluid">
			<div class="flex flex-col gap">
				@HXDetails(
					utils.HXGetToolOverlappingTools(),
					"section-admin-overlapping-tools",
					"bi-exclamation-triangle",
					"Admin Tools: Werkzeug-Überschneidungen",
				)
				@HXDetails(
					utils.HXGetToolsPagePressSectionContent(),
					"section-press",
					"bi-gear-fill",
					"Eingebaute Werkzeuge",
				)
				@HXDetails(
					utils.HXGetToolsPageAllToolsSectionContent(),
					"section-tools-list",
					"bi-archive",
					"Alle Werkzeuge",
				)
			</div>
			<script>
				document.addEventListener('DOMContentLoaded', function() {
					const params = new URLSearchParams(window.location.search);
					if (params.toString()) {
						const toolsSection = document.getElementById('section-tools-list');
						if (toolsSection) {
							toolsSection.open = true;
							htmx.trigger(toolsSection, 'toggle');
						}
					}
				});
			</script>
		</main>
	}
}

templ PageTools_SectionPress(pressUtilization []models.PressUtilization) {
	<span
		hx-get={ utils.HXGetToolsPagePressSectionContent() }
		hx-trigger="pageLoaded from:body"
		hx-target="#section-press"
		hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
	></span>
	<summary>
		<h4>
			<i class="bi bi-gear-fill mr"></i>
			Eingebaute Werkzeuge
		</h4>
	</summary>
	<ul class="flex flex-col gap m-0 p-0" style="list-style: none;">
		for _, u := range pressUtilization {
			{{
				var (
					top         string
					topCassette string
					bottom      string
				)

				for _, t := range u.Tools {
					switch t.Position {
					case models.PositionTop:
						top = fmt.Sprintf("%s %s %s", t.Format.String(), t.Code, t.Type)
					case models.PositionTopCassette:
						topCassette = fmt.Sprintf("%s %s %s", t.Format.String(), t.Code, t.Type)
					case models.PositionBottom:
						bottom = fmt.Sprintf("%s %s %s", t.Format.String(), t.Code, t.Type)
					}
				}
			}}
			@pageTools_SectionPress_ListItem(pageTools_SectionPress_ListItemProps{
				Title:       fmt.Sprintf("Presse %d", u.PressNumber),
				Top:         top,
				TopCassette: topCassette,
				Bottom:      bottom,
				Href:        fmt.Sprintf("%s/tools/press/%d", env.ServerPathPrefix, u.PressNumber),
			})
		}
	</ul>
}

type pageTools_SectionPress_ListItemProps struct {
	Title       string
	Top         string
	TopCassette string
	Bottom      string
	Href        string
}

templ pageTools_SectionPress_ListItem(props pageTools_SectionPress_ListItemProps) {
	<li title={ props.Title }>
		<a
			role="button"
			href={ props.Href }
			class="outline contrast flex justify-between items-center"
		>
			<span class="flex flex-col gap-lg w-full">
				<h5>{ props.Title }</h5>
				<span class="flex flex-wrap gap-lg justify-between items-center w-full">
					if props.Top != "" || props.TopCassette != "" {
						@pageTools_RenderTopTools(props.Top, props.TopCassette)
					}
					if props.Bottom != "" {
						@pageTools_RenderBottomTools(props.Bottom)
					}
				</span>
			</span>
			<i class="bi bi-chevron-right"></i>
		</a>
	</li>
}

templ pageTools_RenderTopTools(top, cassette string) {
	<!-- Upper Tool -->
	<span class="flex flex-col gap-sm">
		if top != "" {
			<span class="flex flex-col gap-0 justify-center items-start gap-sm">
				@PositionBadge(
					models.PositionTop, "primary text-bold",
				)
				<small class="text-sm">{ top }</small>
			</span>
		}
		if cassette != "" {
			<span class="flex flex-col gap-0 justify-center items-start gap-sm">
				@PositionBadge(
					models.PositionTopCassette, "primary text-bold",
				)
				<small class="text-sm">{ cassette }</small>
			</span>
		}
	</span>
}

templ pageTools_RenderBottomTools(bottom string) {
	<!-- Lower Tool -->
	<span class="flex flex-col justify-center items-start gap-sm">
		@PositionBadge(models.PositionBottom, "primary text-bold")
		<small class="text-sm">{ bottom }</small>
	</span>
}

templ PageTools_SectionTools(tools []*models.ResolvedTool) {
	<span
		hx-get={ utils.HXGetToolsPageAllToolsSectionContent() }
		hx-trigger="pageLoaded from:body"
		hx-target="#section-tools-list"
		hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
	></span>
	<summary>
		<h4>
			<i class="bi bi-archive mr"></i>
			Alle Werkzeuge
		</h4>
	</summary>
	@pageTools_sectionToolsFilter(tools)
	<div class="all-tools p">
		<div class="actions-bar flex gap justify-end items-center">
			<button
				type="button"
				class="primary flex gap"
				hx-get={ utils.HXGetToolEditDialog(nil) }
				hx-trigger="click"
				hx-target="body"
				hx-swap="beforeend"
				hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
			>
				<i class="bi bi-plus-lg"></i>
				<span>Erstellen</span>
			</button>
		</div>
		<ul class="flex flex-col gap m-t p-0" style="list-style: none;">
			@PageTools_ToolsList(tools)
		</ul>
	</div>
	@pageTools_sectionToolsFilterScript()
}

templ pageTools_sectionToolsFilter(tools []*models.ResolvedTool) {
	<div class="flex gap-sm flex-wrap justify-evenly">
		<!-- Filter for Tool Format -->
		<label class="flex flex-1 flex-col gap-0" style="width: 100%;">
			Suche (Lazy)
			<input
				id={ PageTools_IDToolsFilter }
				type="search"
				oninput="filterToolsList();"
				placeholder="z.B.: kassette 120x60 mass"
				hx-preserve="true"
			/>
		</label>
	</div>
}

templ pageTools_sectionToolsFilterScript() {
	<script>
		function filter(value) {
			for (var el of document.querySelectorAll(`.all-tools ul > *`)) {
				// Get the text content of the element
				var textContent = el.textContent.toLowerCase();

				// Generate special regexp from search
				var valueSplit = document.querySelector("input#{{ PageTools_IDToolsFilter }}").value.toLowerCase().split(' ');

				// Check and Set "block" or "none"
				let shouldNotHide = true;
				for (var char of valueSplit) {
					if (char === "") continue;

					if (!textContent.includes(char)) {
						shouldNotHide = false;
						break;
					}
				}

				el.style.display = shouldNotHide ? "block" : "none";
			}
		}

		function filterToolsList() {
			var params = new URLSearchParams(location.search);

			var inputValue = document.querySelector("input#{{ PageTools_IDToolsFilter }}").value;

			if (inputValue !== "") {
				params.set("tools_filter", inputValue);
			} else {
				params.delete("tools_filter");
			}

			filter(inputValue);


			// Update browser history to include filter parameters
			var newUrl = window.location.pathname + (params.toString() ? '?' + params.toString() : '');
			window.history.replaceState({}, '', newUrl);
		}

		setTimeout(function() {
			var params = new URLSearchParams(window.location.search);
			document.querySelector("input#{{ PageTools_IDToolsFilter }}").value = params.get("tools_filter");
			filterToolsList();
		}, 100);
	</script>
}

templ PageTools_ToolsList(tools []*models.ResolvedTool) {
	for _, t := range tools {
		if t.Position != models.PositionTopCassette || !t.IsBound() {
			@pageTools_toolListItem(t.ID, t)
		}
	}
}

templ pageTools_toolListItem(id int64, tool *models.ResolvedTool) {
	<li id={ fmt.Sprintf("tool-%d", id) }>
		@ToolAnchor(tool, &ToolAnchorOptions{
			EnableStatusBadge:  true,
			EnableBindingBadge: true,
			EnableTotalCycles:  true,
		})
	</li>
}

templ PageTools_AdminOverlappingToolsSectionContent(overlappingTools []*models.OverlappingTool) {
	<span
		hx-get={ utils.HXGetToolOverlappingTools() }
		hx-trigger="pageLoaded from:body"
		hx-target="#section-admin-overlapping-tools"
		hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
	></span>
	<summary class="mb">
		<h4>
			<i class="bi bi-exclamation-triangle mr"></i>
			Admin Tools: Werkzeug-Überschneidungen
		</h4>
	</summary>
	<div class="admin-overlapping-tools">
		if len(overlappingTools) == 0 {
			<div class="card success outline p text-center">
				<div class="flex justify-center items-center gap">
					<i class="bi bi-check-circle-fill text-lg"></i>
					<div>
						<h5 class="m-0">Keine Überschneidungen gefunden</h5>
						<p class="muted border m-0">Alle Werkzeuge sind korrekt auf einzelne Pressen beschränkt.</p>
					</div>
				</div>
			</div>
		} else {
			<div class="card warning outline p mb">
				<div class="flex items-center gap">
					<i class="bi bi-exclamation-triangle-fill text-lg"></i>
					<div>
						<h5 class="m-0">Überschneidungen erkannt!</h5>
						<p class="muted border m-0">
							{ fmt.Sprintf("Es wurden %d Werkzeuge gefunden, die gleichzeitig an mehreren Pressen verwendet wurden.", len(overlappingTools)) }
						</p>
					</div>
				</div>
			</div>
			<div class="flex flex-col gap">
				for _, tool := range overlappingTools {
					<div class="card error outline p">
						<div class="mb">
							<h6 class="m-0">{ tool.ToolCode }</h6>
							<small>
								<pre>
									@templ.Raw(fmt.Sprintf(
										"Tool ID:  %s\n"+
											"Zeitraum: %s - %s",
										fmt.Sprintf("%d", tool.ToolID),
										tool.StartDate.Format(env.DateFormat),
										tool.EndDate.Format(env.DateFormat),
									))
								</pre>
							</small>
						</div>
						<div class="overlapping-instances">
							<h6>Betroffene Pressen:</h6>
							<div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: var(--ui-spacing);">
								for _, instance := range tool.Overlaps {
									<div class="border p-sm">
										<div class="flex justify-between items-center mb-sm">
											<strong>Presse { fmt.Sprintf("%d", instance.PressNumber) }</strong>
											@PositionBadge(instance.Position, "secondary")
										</div>
										<pre>
											@templ.Raw(fmt.Sprintf(
												"Start: %s\n"+
													"Ende:  %s\n"+
													"Dauer: %s",
												instance.StartDate.Format(env.DateTimeFormat),
												instance.EndDate.Format(env.DateTimeFormat),
												pageTools_formatDuration(instance.EndDate.Sub(instance.StartDate)),
											))
										</pre>
									</div>
								}
							</div>
						</div>
					</div>
				}
			</div>
		}
	</div>
}

func pageTools_formatDuration(d time.Duration) string {
	days := int(d.Hours() / 24)
	hours := int(d.Hours()) % 24

	if days > 0 {
		return fmt.Sprintf("%d Tage, %d Stunden", days, hours)
	} else if hours > 0 {
		return fmt.Sprintf("%d Stunden", hours)
	} else {
		minutes := int(d.Minutes())
		return fmt.Sprintf("%d Minuten", minutes)
	}
}
