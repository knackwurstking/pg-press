package components

import (
	"fmt"
	"github.com/knackwurstking/pgpress/env"
	"github.com/knackwurstking/pgpress/models"
	"github.com/knackwurstking/pgpress/utils"
)

type PageToolProps struct {
	User       *models.User
	ToolString string
	ToolID     int64
	Position   models.Position
}

templ PageTool(props *PageToolProps) {
	@Layout(
		LayoutOptions{
			PageTitle: fmt.Sprintf("PG Presse | %s %s",
				props.ToolString, props.Position.GermanString()),
			AppBarTitle: fmt.Sprintf("%s %s",
				props.ToolString, props.Position.GermanString()),
			NavContent: pageTool_navContent(),
		},
	) {
		<main class="container fluid flex flex-col gap">
			@pageTool_sectionActions(props.User, props.ToolID)
			<section
				id="notes-section"
				hx-get={ utils.HXGetToolNotesSectionContent(props.ToolID) }
				hx-trigger="load, pageLoaded from:body"
				hx-swap="innerHTML"
				hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
			>
				@Spinner()
			</section>
			if props.Position == models.PositionTop || props.Position == models.PositionBottom {
				<section
					id="metal-sheets-section"
					hx-get={ utils.HXGetToolMetalSheetsSectionContent(props.ToolID) }
					hx-trigger="load, pageLoaded from:body"
					hx-swap="innerHTML"
					hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
				>
					@Spinner()
				</section>
			}
			@PageTool_CyclesSection(props.ToolID, false)
		</main>
	}
}

templ PageTool_CyclesSection(toolID int64, oob bool) {
	<section
		id="cycles-section"
		hx-get={ utils.HXGetToolCyclesSectionContent(toolID) }
		hx-trigger="load, pageLoaded from:body"
		hx-swap="innerHTML"
		if oob {
			hx-swap-oob="true"
		}
		hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
	>
		@Spinner()
	</section>
}

templ pageTool_sectionActions(user *models.User, toolID int64) {
	<section class="action-bar flex gap justify-end items-center">
		<button
			class="primary flex gap"
			hx-get={ utils.HXGetToolEditDialog(&toolID) }
			hx-trigger="click"
			hx-target="body"
			hx-swap="beforeend"
			hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
		>
			<i class="bi bi-pencil"></i>
			Bearbeiten
		</button>
		<button
			class="destructive flex gap"
			hx-patch={ utils.HXPatchToolMarkDead(toolID) }
			hx-trigger="click"
			hx-confirm="Sind Sie sicher, dass Sie dieses Werkzeug löschen möchten?"
			hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
			if !user.IsAdmin() {
				disabled
			}
		>
			<i class="bi bi-trash"></i>
			Löschen
		</button>
	</section>
}

templ pageTool_navContent() {
	@NavFeedButton()
	@NavProfileButton()
	@NavHomeButton()
}

type PageTool_BindingSectionProps struct {
	Tool            *models.ResolvedTool
	ToolsForBinding []*models.Tool
	IsAdmin         bool
}

templ PageTool_BindingSection(props PageTool_BindingSectionProps) {
	{{
		var positionForBinding models.Position
		if props.Tool.Position == models.PositionTop {
			positionForBinding = models.PositionTopCassette
		} else {
			positionForBinding = models.PositionTop
		}
	}}
	<span id="binding-section" class="flex flex-col gap">
		@SectionTitle(SectionTitleLevelSub, "Werkzeuge Binden")
		<span
			class="flex gap flex-wrap"
			if !props.IsAdmin {
				disabled
			}
		>
			<select
				id="tool-binding-select"
				hx-patch={ utils.HXPatchToolBind(props.Tool.ID) }
				hx-vals="js:{target_id: event.target.value}"
				hx-trigger="change"
				hx-target="#binding-section"
				hx-swap="outerHTML"
				hx-on:htmx:response-error="alert(event.detail.xhr.responseText);"
				if props.Tool.Binding != nil {
					disabled
				}
			>
				<option
					value=""
					disabled
					selected?={ props.Tool.Binding == nil }
				>
					{ positionForBinding.GermanString() } Binden
				</option>
				for _, t := range props.ToolsForBinding {
					<option
						value={ t.ID }
						selected?={ props.Tool.Binding != nil && t.ID == *props.Tool.Binding }
					>{ t.Code } { t.Type }</option>
				}
			</select>
			<button
				class="small ghost destructive"
				hx-patch={ utils.HXPatchToolUnbind(props.Tool.ID) }
				hx-trigger="click"
				hx-target="#binding-section"
				hx-swap="outerHTML"
				hx-on:htmx:response-error="alert(event.detail.xhr.responseText);"
				if !props.Tool.IsBound() {
					disabled
				}
			>
				Entbinden
			</button>
		</span>
		if props.Tool.IsBound() {
			<span>
				@ToolAnchor(
					models.NewResolvedTool(props.Tool.GetBindingTool(),
						props.Tool.Tool, props.Tool.GetNotes()),
					nil,
				)
			</span>
		}
	</span>
}

type PageTool_CyclesProps struct {
	User            *models.User
	Tool            *models.ResolvedTool
	ToolsForBinding []*models.Tool
	ToolPosition    string
	TotalCycles     int64
	Cycles          []*models.Cycle
	Regenerations   []*models.ResolvedRegeneration
}

templ PageTool_Cycles(props PageTool_CyclesProps) {
	@SectionTitle(SectionTitleLevelMain, "Werkzeugnutzung & Zyklen")
	<div class="flex flex-col gap">
		@pageTool_toolStatusSection(props)
		@pageTool_RegenerationsSection(props)
		@pageTool_CyclesSection(props)
	</div>
}

templ pageTool_toolStatusSection(props PageTool_CyclesProps) {
	<section id="tool-status-section">
		@SectionTitle(SectionTitleLevelSub, "Aktueller Status")
		@pageTool_toolStatus(props.Tool, props.ToolsForBinding, props.User)
	</section>
}

templ pageTool_toolStatus(tool *models.ResolvedTool, toolsForBinding []*models.Tool, user *models.User) {
	<div class="flex flex-col gap">
		<span class="flex gap-lg">
			@ToolPage_ToolStatusEdit(&ToolPage_ToolStatusEditProps{
				Tool:              tool.Tool,
				UserHasPermission: user.IsAdmin(),
			})
			if tool.IsActive() {
				<a
					role="button"
					class="small ghost flex gap"
					href={ fmt.Sprintf("%s/tools/press/%d", env.ServerPathPrefix, *tool.Press) }
					title="Zur Pressenübersicht"
				>
					<i class="bi bi-arrow-right"></i>
					Presse { fmt.Sprintf("%d", *tool.Press) }
				</a>
			}
		</span>
		if tool.IsBindable() {
			@PageTool_BindingSection(PageTool_BindingSectionProps{
				Tool:            tool,
				ToolsForBinding: toolsForBinding,
				IsAdmin:         user.IsAdmin(),
			})
		}
	</div>
}

templ pageTool_RegenerationsSection(props PageTool_CyclesProps) {
	<section id="regenerations-section">
		@SectionTitle(SectionTitleLevelSub, "Regenerationen")
		if len(props.Regenerations) == 0 {
			<span class="flex justify-center items-center">
				<i><small>Keine Regenerationen verzeichnet für dieses Werkzeug</small></i>
			</span>
		} else {
			@pageTool_RegenerationsTable(props.Regenerations, props.User)
		}
	</section>
}

templ pageTool_RegenerationsTable(regenerations []*models.ResolvedRegeneration, user *models.User) {
	<figure class="w-full overflow-x-scroll">
		<table title="Regenerationen">
			<thead>
				<tr>
					<th name="date">Datum</th>
					<th name="reason">Grund</th>
					<th name="actions"></th>
				</tr>
			</thead>
			<tbody>
				if len(regenerations) == 0 {
					<tr>
						<td colspan="3" class="text-center">
							<i><small>Keine Regenerationen verzeichnet</small></i>
						</td>
					</tr>
				} else {
					@pageTool_RegenerationsTableRows(regenerations, user)
				}
			</tbody>
		</table>
	</figure>
}

templ pageTool_RegenerationsTableRows(regenerations []*models.ResolvedRegeneration, user *models.User) {
	for _, regen := range regenerations {
		<tr>
			<td>
				<span>{ regen.GetCycle().Date.Format(env.DateFormat) }</span>
			</td>
			<td>
				<span>{ regen.Reason }</span>
			</td>
			<td>
				@TableActions(TableActionsOptions{
					EditHref:        utils.HXGetToolRegenerationEdit(regen.GetTool().ID, &regen.ID),
					EditAdminOnly:   false,
					DeleteHref:      utils.HXDeleteToolRegeneration(regen.GetTool().ID, regen.ID),
					DeleteAdminOnly: true,
					User:            user,
				})
			</td>
		</tr>
	}
}

templ pageTool_CyclesSection(props PageTool_CyclesProps) {
	<section id="cycles-section">
		@SectionTitle(SectionTitleLevelSub, "Pressennutzungsverlauf") {
			<button
				class="icon secondary small flex"
				hx-get={ utils.HXGetCycleEditDialog(props.Tool.ID, nil, false) }
				hx-trigger="click"
				hx-target="body"
				hx-swap="beforeend"
				hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
				title="Neuen Eintrag hinzufügen"
				if !props.User.IsAdmin() {
					disabled
				}
			>
				<i class="bi bi-plus-lg"></i>
			</button>
		}
		<section>
			<h6 class="mb">
				Gesamtzyklen für "{ fmt.Sprintf("%s %s %s", props.Tool.Format.String(), props.Tool.Code, props.Tool.Type) }":
			</h6>
			<span>
				@TotalCycles(props.TotalCycles, true)
			</span>
		</section>
		@pageTool_CyclesTable(props)
	</section>
}

templ pageTool_CyclesTable(props PageTool_CyclesProps) {
	<figure class="w-full overflow-x-scroll">
		<table
			name="tool-cycles-table"
			class="table borderless compact"
			title="Zyklusverlauf"
		>
			<thead>
				<tr>
					<th name="press">Presse</th>
					<th name="date">Datum</th>
					<th name="total">Gesamtzyklen</th>
					<th name="partial">Teilzyklen (berechnet)</th>
					<th></th>
				</tr>
			</thead>
			<tbody>
				if len(props.Cycles) == 0 {
					<tr>
						<td colspan="5" class="text-center">
							<i><small>Kein Pressenverlauf verfügbar</small></i>
						</td>
					</tr>
				} else {
					{{
						var lastRegeneration *models.ResolvedRegeneration
						if len(props.Regenerations) > 0 {
							lastRegeneration = props.Regenerations[0]
						}
					}}
					for _, cycle := range props.Cycles {
						@pageTool_CycleRowWithPartialCalc(cycle, lastRegeneration, props)
					}
				}
			</tbody>
		</table>
	</figure>
}

templ pageTool_CycleRowWithPartialCalc(
	cycle *models.Cycle,
	lastRegeneration *models.ResolvedRegeneration,
	props PageTool_CyclesProps,
) {
	<tr
		if lastRegeneration != nil && lastRegeneration.CycleID == cycle.ID {
			style="color: var(--ui-muted);"
		}
	>
		<td>
			<span>{ fmt.Sprintf("%d", cycle.PressNumber) }</span>
		</td>
		<td>
			<span class="text-sm">{ cycle.Date.Format(env.DateFormat) }</span>
		</td>
		<td>
			{ fmt.Sprintf("%d", cycle.TotalCycles) }
		</td>
		<td>
			<span title="Berechnet: Gesamtzyklen - Gesamtzyklen des letzten Eintrags">
				{ fmt.Sprintf("%d", cycle.PartialCycles) }
			</span>
		</td>
		<td>
			@TableActions(TableActionsOptions{
				EditHref:        utils.HXGetCycleEditDialog(props.Tool.ID, &cycle.ID, false),
				EditAdminOnly:   true,
				DeleteHref:      utils.HXDeleteCycle(cycle.ID, props.Tool.ID),
				DeleteAdminOnly: true,
				User:            props.User,
			})
		</td>
	</tr>
}

type ToolPage_ToolStatusEditProps struct {
	Tool              *models.Tool
	Editable          bool
	UserHasPermission bool
}

templ ToolPage_ToolStatusEdit(props *ToolPage_ToolStatusEditProps) {
	<div
		id={ fmt.Sprintf("tool-status-%d", props.Tool.ID) }
		class="flex flex-col gap-sm"
	>
		if props.Editable {
			@toolPage_toolStatusEditForm(props.Tool, props.UserHasPermission)
		} else {
			@toolPage_toolStatusDisplay(props.Tool)
		}
	</div>
}

templ toolPage_toolStatusDisplay(tool *models.Tool) {
	<div class="flex items-center gap-lg">
		@ToolStatusBadge(tool)
		<button
			type="button"
			class="small ghost flex gap"
			hx-get={ utils.HXGetToolStatusEdit(tool.ID) }
			hx-target={ fmt.Sprintf("#tool-status-%d", tool.ID) }
			hx-swap="outerHTML"
			title="Status bearbeiten"
			if tool.IsActive() {
				disabled
			}
		>
			<i class="bi bi-pencil-square text-sm"></i>
			Regenerierung
		</button>
	</div>
}

templ toolPage_toolStatusEditForm(tool *models.Tool, userHasPermission bool) {
	<div class="card p-sm flex flex-col gap-sm">
		<div class="flex items-center gap-sm mb-sm">
			@ToolStatusBadge(tool)
			<span class="text-sm text-muted">Regenerierung steuern</span>
		</div>
		<div class="flex flex-col gap-sm">
			<form
				hx-put={ utils.HXPutToolStatus() }
				hx-target={ fmt.Sprintf("#tool-status-%d", tool.ID) }
				hx-swap="outerHTML"
			>
				<input type="hidden" name="tool_id" value={ fmt.Sprintf("%d", tool.ID) }/>
				if tool.Status() != models.StatusRegenerating {
					<input type="hidden" name="status" value="regenerating"/>
				} else {
					<input type="hidden" name="status" value="active"/>
				}
				<button
					type="submit"
					if tool.Status() != models.StatusRegenerating {
						class="small warning w-full m-0 flex gap"
					} else {
						class="small success w-full m-0 flex gap"
					}
					if !userHasPermission {
						disabled
					}
				>
					<i class="bi bi-arrow-clockwise"></i>
					if tool.Status() != models.StatusRegenerating {
						Regenerierung starten
					} else {
						Regenerierung stoppen
					}
				</button>
			</form>
			if tool.Status() == models.StatusRegenerating {
				<form
					hx-put={ utils.HXPutToolStatus() }
					hx-target={ fmt.Sprintf("#tool-status-%d", tool.ID) }
					hx-swap="outerHTML"
				>
					<input type="hidden" name="tool_id" value={ fmt.Sprintf("%d", tool.ID) }/>
					<input type="hidden" name="status" value="abort"/>
					<button
						type="submit"
						class="small destructive w-full m-0 flex gap"
						if !userHasPermission {
							disabled
						}
					>
						<i class="bi bi-trash"></i>
						Regenerierung Abbrechen
					</button>
				</form>
			}
			<button
				type="button"
				class="small secondary flex gap"
				hx-get={ utils.HXGetToolStatusDisplay(tool.ID) }
				hx-target={ fmt.Sprintf("#tool-status-%d", tool.ID) }
				hx-swap="outerHTML"
			>
				<i class="bi bi-x"></i>
				Abbrechen
			</button>
		</div>
	</div>
}

templ PageTool_MetalSheets(user *models.User, metalSheets models.MetalSheetList, tool *models.Tool) {
	{{ metalSheets := metalSheets.Sort() }}
	if tool.Position == models.PositionTop || tool.Position == models.PositionBottom {
		@SectionTitle(SectionTitleLevelMain, "Bleche") {
			<button
				class="icon secondary small flex"
				hx-get={ utils.HXGetMetalSheetEditDialog(nil, &tool.ID) }
				hx-trigger="click"
				hx-target="body"
				hx-swap="beforeend"
				hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
				title="Neues Blech hinzufügen"
			>
				<i class="bi bi-plus-lg"></i>
			</button>
		}
		<div class="table-container">
			switch tool.Position {
				case models.PositionBottom:
					@PageTool_MetalSheetTableBottom(user, metalSheets)
				case models.PositionTop:
					@PageTool_MetalSheetTableTop(user, metalSheets)
			}
		</div>
	}
}

templ PageTool_MetalSheetTableTop(user *models.User, metalSheets []*models.MetalSheet) {
	<figure class="w-full overflow-x-scroll">
		<table class="table borderless compact">
			<thead>
				<tr>
					<th>Stärke (mm)</th>
					<th>Blech (mm)</th>
					<th>Typ</th>
					<th></th>
				</tr>
			</thead>
			<tbody>
				if len(metalSheets) == 0 {
					<tr>
						<td colspan="4" class="text-center">
							<i><small>Keine Bleche für dieses Werkzeug gefunden</small></i>
						</td>
					</tr>
				} else {
					for _, sheet := range metalSheets {
						<tr>
							<td>{ fmt.Sprintf("%.1f", sheet.TileHeight) }</td>
							<td>{ fmt.Sprintf("%.1f", sheet.Value) }</td>
							<td>
								<span class="badge small">{ sheet.Identifier.String() }</span>
							</td>
							<td class="button-group flex justify-end items-center">
								@TableActions(TableActionsOptions{
									EditHref:        utils.HXGetMetalSheetEditDialog(&sheet.ID, nil),
									EditAdminOnly:   false,
									DeleteHref:      utils.HXDeleteMetalSheet(sheet.ID),
									DeleteAdminOnly: true,
									User:            user,
								})
							</td>
						</tr>
					}
				}
			</tbody>
		</table>
	</figure>
}

templ PageTool_MetalSheetTableBottom(user *models.User, metalSheets []*models.MetalSheet) {
	<figure class="w-full overflow-x-scroll">
		<table class="table borderless compact">
			<thead>
				<tr>
					<th>Stärke (mm)</th>
					<th>Blech (mm)</th>
					<th>Marke (mm)</th>
					<th>Stf.</th>
					<th>Hubende</th>
					<th>Typ</th>
					<th></th>
				</tr>
			</thead>
			<tbody>
				if len(metalSheets) == 0 {
					<tr>
						<td colspan="7" class="text-center">
							<i><small>Keine Bleche für dieses Werkzeug gefunden</small></i>
						</td>
					</tr>
				} else {
					for _, sheet := range metalSheets {
						<tr>
							<td>{ fmt.Sprintf("%.1f", sheet.TileHeight) }</td>
							<td>{ fmt.Sprintf("%.1f", sheet.Value) }</td>
							<td>{ fmt.Sprintf("%d", sheet.MarkeHeight) }</td>
							<td>{ fmt.Sprintf("%.1f", sheet.STF) }</td>
							<td>{ fmt.Sprintf("%.1f", sheet.STFMax) }</td>
							<td>
								<span class="badge small">{ sheet.Identifier.String() }</span>
							</td>
							<td class="button-group flex justify-end items-center">
								@TableActions(TableActionsOptions{
									EditHref:        utils.HXGetMetalSheetEditDialog(&sheet.ID, nil),
									EditAdminOnly:   false,
									DeleteHref:      utils.HXDeleteMetalSheet(sheet.ID),
									DeleteAdminOnly: true,
									User:            user,
								})
							</td>
						</tr>
					}
				}
			</tbody>
		</table>
	</figure>
}

templ PageTool_Notes(tool *models.ResolvedTool) {
	@SectionTitle(SectionTitleLevelSub, "Notizen") {
		<button
			class="icon secondary small flex"
			hx-get={ utils.HXGetNotesEditDialog(nil, fmt.Sprintf("tool_%d", tool.ID)) }
			hx-trigger="click"
			hx-target="body"
			hx-swap="beforeend"
			hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
			title="Neue Notiz hinzufügen"
		>
			<i class="bi bi-plus-lg"></i>
		</button>
	}
	if len(tool.GetNotes()) > 0 {
		<div class="notes-list">
			for _, note := range tool.GetNotes() {
				@NoteCard(note)
			}
		</div>
	} else {
		<div class="empty-state">
			<p class="text-muted">Keine Notizen für dieses Werkzeug vorhanden.</p>
		</div>
	}
}

templ PageTool_DialogEditRegeneration(r *models.ResolvedRegeneration) {
	{{
		var (
			baseType         = "PUT"
			submitButtonText = "Aktualisieren"
			baseHref         = utils.HXPutToolRegenerationEdit(r.GetTool().ID, r.ID)
		)
	}}
	@BaseDialog(BaseDialogProps{
		Type:             baseType,
		Href:             baseHref,
		ID:               "regeneration-edit-dialog",
		SubmitButtonText: submitButtonText,
	}) {
		<section>
			<p>Tool: { r.GetTool().String() }</p>
			<p>Regeneriert am: { r.GetCycle().Date.Format(env.DateFormat) }</p>
		</section>
		<label class="flex flex-col gap-0">
			Grund
			<input
				id="reason"
				name="reason"
				type="text"
				value={ r.Reason }
			/>
		</label>
	}
}
