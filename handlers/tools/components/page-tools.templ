package components

import (
	"fmt"
	"github.com/knackwurstking/pg-press/components"
	"github.com/knackwurstking/pg-press/env"
	"github.com/knackwurstking/pg-press/models"
	"github.com/knackwurstking/pg-press/utils"
	"github.com/knackwurstking/ui"
	"time"
)

const (
	PageTools_IDToolsFilter      = "tools-filter"
	PageTools_IDSectionToolsList = "section-tools-list"
)

type pageTools_SectionPress_ListItemProps struct {
	Title       string
	Top         string
	TopCassette string
	Bottom      string
	Href        string
}

templ PageTools() {
	@components.Layout(
		components.LayoutOptions{
			PageTitle:      "PG Presse | Werkzeuge",
			AppBarTitle:    "Werkzeuge",
			NavContent:     components.StandardNavContent(),
			AdditionalHead: pageTools_additionalHead(),
		},
	) {
		<main class="container fluid">
			<div class="flex flex-col gap">
				@components.HXDetails(
					utils.HXGetToolOverlappingTools(),
					"section-admin-overlapping-tools",
					"bi-exclamation-triangle",
					"Admin Tools: Werkzeug-Überschneidungen",
				)
				@components.HXDetails(
					utils.HXGetToolsPagePressSectionContent(),
					"section-press",
					"bi-gear-fill",
					"Eingebaute Werkzeuge",
				)
				@components.HXDetails(
					utils.HXGetToolsPageAllToolsSectionContent(),
					PageTools_IDSectionToolsList,
					"bi-archive",
					"Alle Werkzeuge",
				)
			</div>
		</main>
	}
}

templ pageTools_additionalHead() {
	<script src={ ui.AssetURL(env.ServerPathPrefix, "/js/page-tools.js") }></script>
	<style>
		#section-tools-list {
			min-height: 100vh;
		}
	</style>
}

templ PageTools_AdminOverlappingToolsSectionContent(overlappingTools []*models.OverlappingTool) {
	<span
		hx-get={ utils.HXGetToolOverlappingTools() }
		hx-trigger="pageLoaded from:body"
		hx-target="#section-admin-overlapping-tools"
		hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
	></span>
	<summary class="mb">
		<h4>
			<i class="bi bi-exclamation-triangle mr"></i>
			Admin Tools: Werkzeug-Überschneidungen
		</h4>
	</summary>
	<div class="admin-overlapping-tools">
		if len(overlappingTools) == 0 {
			<div class="card success outline p text-center">
				<div class="flex justify-center items-center gap">
					<i class="bi bi-check-circle-fill text-lg"></i>
					<div>
						<h5 class="m-0">Keine Überschneidungen gefunden</h5>
						<p class="muted border m-0">Alle Werkzeuge sind korrekt auf einzelne Pressen beschränkt.</p>
					</div>
				</div>
			</div>
		} else {
			<div class="card warning outline p mb">
				<div class="flex items-center gap">
					<i class="bi bi-exclamation-triangle-fill text-lg"></i>
					<div>
						<h5 class="m-0">Überschneidungen erkannt!</h5>
						<p class="muted border m-0">
							{ fmt.Sprintf("Es wurden %d Werkzeuge gefunden, die gleichzeitig an mehreren Pressen verwendet wurden.", len(overlappingTools)) }
						</p>
					</div>
				</div>
			</div>
			<div class="flex flex-col gap">
				for _, tool := range overlappingTools {
					<div class="card error outline p">
						<div class="mb">
							<h6 class="m-0">{ tool.ToolCode }</h6>
							<small>
								<pre>
									@templ.Raw(fmt.Sprintf(
										"Tool ID:  %s\n"+
											"Zeitraum: %s - %s",
										fmt.Sprintf("%d", tool.ToolID),
										tool.StartDate.Format(env.DateFormat),
										tool.EndDate.Format(env.DateFormat),
									))
								</pre>
							</small>
						</div>
						<div class="overlapping-instances">
							<h6>Betroffene Pressen:</h6>
							<div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: var(--ui-spacing);">
								for _, instance := range tool.Overlaps {
									<div class="border p-sm">
										<div class="flex justify-between items-center mb-sm">
											<strong>Presse { fmt.Sprintf("%d", instance.PressNumber) }</strong>
											@components.PositionBadge(instance.Position, "secondary")
										</div>
										<pre>
											@templ.Raw(fmt.Sprintf(
												"Start: %s\n"+
													"Ende:  %s\n"+
													"Dauer: %s",
												instance.StartDate.Format(env.DateTimeFormat),
												instance.EndDate.Format(env.DateTimeFormat),
												pageTools_formatDuration(instance.EndDate.Sub(instance.StartDate)),
											))
										</pre>
									</div>
								}
							</div>
						</div>
					</div>
				}
			</div>
		}
	</div>
}

templ PageTools_SectionPress(pressUtilization []models.PressUtilization) {
	<span
		hx-get={ utils.HXGetToolsPagePressSectionContent() }
		hx-trigger="pageLoaded from:body"
		hx-target="#section-press"
		hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
	></span>
	<summary>
		<h4>
			<i class="bi bi-gear-fill mr"></i>
			Eingebaute Werkzeuge
		</h4>
	</summary>
	<ul class="flex flex-col gap m-0 p-0" style="list-style: none;">
		for _, u := range pressUtilization {
			{{
				var (
					top         string
					topCassette string
					bottom      string
				)

				for _, t := range u.Tools {
					switch t.Position {
					case models.PositionTop:
						top = fmt.Sprintf("%s %s %s", t.Format.String(), t.Code, t.Type)
					case models.PositionTopCassette:
						topCassette = fmt.Sprintf("%s %s %s", t.Format.String(), t.Code, t.Type)
					case models.PositionBottom:
						bottom = fmt.Sprintf("%s %s %s", t.Format.String(), t.Code, t.Type)
					}
				}
			}}
			@pageTools_sectionPress_listItem(pageTools_SectionPress_ListItemProps{
				Title:       fmt.Sprintf("Presse %d", u.PressNumber),
				Top:         top,
				TopCassette: topCassette,
				Bottom:      bottom,
				Href:        fmt.Sprintf("%s/tools/press/%d", env.ServerPathPrefix, u.PressNumber),
			})
		}
	</ul>
}

templ pageTools_sectionPress_listItem(props pageTools_SectionPress_ListItemProps) {
	<li title={ props.Title }>
		<a
			role="button"
			href={ props.Href }
			class="outline contrast flex justify-between items-center"
		>
			<span class="flex flex-col gap-lg w-full">
				<h5>{ props.Title }</h5>
				<span class="flex flex-wrap gap-lg justify-between items-center w-full">
					if props.Top != "" || props.TopCassette != "" {
						@pageTools_sectionPress_renderTopTools(props.Top, props.TopCassette)
					}
					if props.Bottom != "" {
						@pageTools_sectionPress_renderBottomTools(props.Bottom)
					}
				</span>
			</span>
			<i class="bi bi-chevron-right"></i>
		</a>
	</li>
}

templ pageTools_sectionPress_renderTopTools(top, cassette string) {
	<!-- Upper Tool -->
	<span class="flex flex-col gap-sm">
		if top != "" {
			<span class="flex flex-col gap-0 justify-center items-start gap-sm">
				@components.PositionBadge(
					models.PositionTop, "primary text-bold",
				)
				<small class="text-sm">{ top }</small>
			</span>
		}
		if cassette != "" {
			<span class="flex flex-col gap-0 justify-center items-start gap-sm">
				@components.PositionBadge(
					models.PositionTopCassette, "primary text-bold",
				)
				<small class="text-sm">{ cassette }</small>
			</span>
		}
	</span>
}

templ pageTools_sectionPress_renderBottomTools(bottom string) {
	<!-- Lower Tool -->
	<span class="flex flex-col justify-center items-start gap-sm">
		@components.PositionBadge(models.PositionBottom, "primary text-bold")
		<small class="text-sm">{ bottom }</small>
	</span>
}

templ PageTools_SectionTools(tools []*models.ResolvedTool) {
	<span
		hx-get={ utils.HXGetToolsPageAllToolsSectionContent() }
		hx-trigger="pageLoaded from:body"
		hx-target={ fmt.Sprintf("#%s", PageTools_IDSectionToolsList) }
		hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
	></span>
	<summary>
		<h4>
			<i class="bi bi-archive mr"></i>
			Alle Werkzeuge
		</h4>
	</summary>
	@pageTools_sectionTools_Filter(tools)
	<div class="all-tools p">
		<div class="actions-bar flex gap justify-end items-center">
			<button
				type="button"
				class="primary flex gap"
				hx-get={ utils.HXGetToolEditDialog(nil) }
				hx-trigger="click"
				hx-target="body"
				hx-swap="beforeend"
				hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
			>
				<i class="bi bi-plus-lg"></i>
				<span>Erstellen</span>
			</button>
		</div>
		<ul id="tools-list" class="flex flex-col gap m-t p-0" style="list-style: none;">
			@PageTools_ToolsList(tools)
		</ul>
	</div>
	@pageToolsInitializeFilterInput()
}

templ pageTools_sectionTools_Filter(tools []*models.ResolvedTool) {
	<div class="flex gap-sm flex-wrap justify-evenly">
		<!-- Filter for Tool Format -->
		<label class="flex flex-1 flex-col gap-0" style="width: 100%;">
			Suche (Lazy)
			<input
				id={ PageTools_IDToolsFilter }
				type="search"
				oninput="scrollFilterInputIntoView(event); filterToolsList(event);"
				onblur="unscrollFilterInputIntoView(event);"
				placeholder="z.B.: kassette 120x60 mass"
				hx-preserve="true"
			/>
		</label>
	</div>
}

script pageToolsInitializeFilterInput() {
	setTimeout(function () {
		var params = new URLSearchParams(window.location.search);

		const input = document.querySelector(`input#${IDToolsFilter}`);
		if (input) {
			input.value = params.get("tools_filter");
			filterToolsList();
		}
	}, 100);
}

templ PageTools_ToolsList(tools []*models.ResolvedTool) {
	for _, t := range tools {
		if t.Position != models.PositionTopCassette || !t.IsBound() {
			@pageTools_toolsList_listItem(t.ID, t)
		}
	}
}

templ pageTools_toolsList_listItem(id models.ToolID, tool *models.ResolvedTool) {
	<li id={ fmt.Sprintf("tool-%d", id) }>
		@components.ToolAnchor(tool, &components.ToolAnchorOptions{
			EnableStatusBadge:  true,
			EnableBindingBadge: true,
			EnableTotalCycles:  true,
		})
	</li>
}

func pageTools_formatDuration(d time.Duration) string {
	days := int(d.Hours() / 24)
	hours := int(d.Hours()) % 24

	if days > 0 {
		return fmt.Sprintf("%d Tage, %d Stunden", days, hours)
	} else if hours > 0 {
		return fmt.Sprintf("%d Stunden", hours)
	} else {
		minutes := int(d.Minutes())
		return fmt.Sprintf("%d Minuten", minutes)
	}
}
