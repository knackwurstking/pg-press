package templates

import (
	"fmt"
	"github.com/knackwurstking/pg-press/components"
	"github.com/knackwurstking/pg-press/models"
	"github.com/knackwurstking/pg-press/utils"
	"strconv"
)

type PageProps struct {
	Type        models.EditorType // TODO: I could use a type alias here, and also define some constants
	ID          int64
	ReturnURL   templ.SafeURL
	Title       string
	Content     string
	UseMarkdown bool
	Attachments []*models.Attachment
}

templ Page(props *PageProps) {
	{{
		var pageTitle, editorTitle string
		typeName := getTypeName(props.Type)

		if props.ID > 0 {
			pageTitle = fmt.Sprintf("Bearbeiten - %s", typeName)
			editorTitle = fmt.Sprintf("%s bearbeiten", typeName)
		} else {
			pageTitle = fmt.Sprintf("Erstellen - %s", typeName)
			editorTitle = fmt.Sprintf("Neues %s erstellen", typeName)
		}
	}}
	@components.Layout(components.LayoutOptions{
		PageTitle:      pageTitle,
		AppBarTitle:    editorTitle,
		AdditionalHead: pageAdditionalHead(),
		NavContent:     pageNavContent(props),
	}) {
		<main class="container fluid">
			<div class="editor-container">
				<form
					class="editor-form flex flex-col gap px"
					method="POST"
					action={ utils.UrlEditor(props.Type, fmt.Sprintf("%d", props.ID), props.ReturnURL).Save }
					enctype="multipart/form-data"
				>
					@hiddenFields(props)
					@titleInput(props.Title)
					@markdownToggle(props.UseMarkdown)
					@markdownTools()
					@contentTextarea(props.Content)
					@markdownPreview()
					@attachmentsSeparator()
					if supportsAttachments(props.Type) {
						@attachmentsSection(props.Attachments)
					}
					@formActions(props)
				</form>
			</div>
		</main>
		@components.MarkdownScript()
	}
}

templ pageNavContent(props *PageProps) {
	if props.ReturnURL != "" {
		<a href={ props.ReturnURL } class="secondary flex gap">
			<i class="bi bi-arrow-left"></i>
			Zur√ºck
		</a>
	}
}

templ pageAdditionalHead() {
	@components.MarkdownStyles()
	<style>
		.markdown-content h1,
		.markdown-content h2,
		.markdown-content h3,
		.markdown-content h4,
		.markdown-content h5,
		.markdown-content h6 {
			margin: 0.8em 0 0.4em 0;
			font-weight: bold;
			line-height: 1.3;
		}

		.markdown-content h1 { font-size: 1.4em; }
		.markdown-content h2 { font-size: 1.2em; }
		.markdown-content h3 { font-size: 1.1em; }

		.markdown-content p {
			margin: 0.5em 0 1em 0;
		}

		.markdown-content ul,
		.markdown-content ol {
			margin: 0.5em 0;
			padding-left: 1.5em;
			list-style: inherit;
		}

		.markdown-content ul { list-style-type: disc; }
		.markdown-content ol { list-style-type: decimal; }

		.markdown-content li {
			margin: 0.25em 0;
			display: list-item;
		}

		.markdown-content code {
			font-size: 0.85em;
			padding: 0.125em 0.25em;
			border-radius: 2px;
		}

		.markdown-content strong { font-weight: 600; }
		.markdown-content em { font-style: italic; }

		@media (max-width: 768px) {
			#markdown-preview { min-height: 200px; }
			.flex-wrap { justify-content: center; }
		}

		.transition-all:hover { border-color: var(--ui-primary); }
		.border-2:hover {
			border-color: var(--ui-primary);
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
		}

		.file-upload-area:hover,
		.file-upload-area.drag-over { border-color: var(--ui-primary); }

		.preview-fullscreen textarea { display: none; }
		.preview-fullscreen #markdown-preview { min-height: 600px; }
	</style>
	<script>
		var selectedFiles = [];
		var existingAttachmentsRemoval = [];
		var isPreviewFullscreen = false;

		document.addEventListener('DOMContentLoaded', initializeMarkdownFeatures);

		function initializeMarkdownFeatures() {
			var checkbox = document.getElementById('use_markdown');
			if (checkbox) {
				toggleMarkdownFeatures();
			}
		}

		function toggleMarkdownFeatures() {
			var checkbox = document.getElementById('use_markdown');
			var tools = document.getElementById('markdown-tools');
			var previewContainer = document.getElementById('markdown-preview-container');
			var textarea = document.getElementById('content');

			if (checkbox.checked) {
				tools.style.display = 'block';
				previewContainer.style.display = 'block';
				textarea.setAttribute('placeholder', 'Inhalt (Markdown-Formatierung aktiviert)');
				updatePreview();
				textarea.addEventListener('input', updatePreview);
			} else {
				tools.style.display = 'none';
				previewContainer.style.display = 'none';
				textarea.removeEventListener('input', updatePreview);
				textarea.setAttribute('placeholder', 'Inhalt');
			}
		}

		function updatePreview() {
			window.updateMarkdownPreview('content', 'preview-content');
		}

		function togglePreviewMode() {
			var container = document.querySelector('.editor-container');
			var toggleText = document.getElementById('preview-toggle-text');
			var toggleIcon = document.querySelector('#markdown-preview button i');

			isPreviewFullscreen = !isPreviewFullscreen;

			if (isPreviewFullscreen) {
				container.classList.add('preview-fullscreen');
				toggleText.textContent = 'Split';
				toggleIcon.className = 'bi bi-arrows-angle-contract';
			} else {
				container.classList.remove('preview-fullscreen');
				toggleText.textContent = 'Vollbild';
				toggleIcon.className = 'bi bi-arrows-angle-expand';
			}
		}

		function insertMarkdown(before, after) {
			var textarea = document.getElementById('content');
			if (!textarea) return;

			var start = textarea.selectionStart;
			var end = textarea.selectionEnd;
			var selectedText = textarea.value.substring(start, end);
			var newText = before + selectedText + after;

			textarea.value = textarea.value.substring(0, start) + newText + textarea.value.substring(end);

			var newPos = selectedText === '' ? start + before.length : start + before.length + selectedText.length + after.length;

			textarea.focus();
			textarea.setSelectionRange(newPos, newPos);
			updatePreview();
		}

		function updateExistingAttachmentsRemoval() {
			var input = document.getElementById('existing-attachments-removal');
			if (input) {
				input.value = existingAttachmentsRemoval.join(',');
			}
		}

		function formatFileSize(bytes) {
			if (bytes === 0) return "0 Bytes";
			var k = 1024;
			var sizes = ["Bytes", "KB", "MB", "GB"];
			var i = Math.floor(Math.log(bytes) / Math.log(k));
			return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
		}

		function onAttachments(event) {
			selectedFiles = Array.from(event.target.files);
			var previewArea = document.getElementById("file-preview");
			var container = document.getElementById("new-attachments");

			if (!previewArea || !container) return;

			container.innerHTML = "";

			if (selectedFiles.length > 0) {
				previewArea.style.display = "block";

				selectedFiles.forEach((file, index) => {
					var sizeClass = file.size > 10 * 1024 * 1024 ? "attachment-error text-red" : "muted text-sm";
					var sizeText = file.size > 10 * 1024 * 1024 ? "ZU GROSS!" : formatFileSize(file.size);

					var template = previewArea.querySelector('template[name="attachment-item"]');
					if (!template) return;

					var item = template.content.cloneNode(true);

					var nameElement = item.querySelector('.name');
					if (nameElement) nameElement.textContent = file.name;

					var sizeElement = item.querySelector('.size-text');
					if (sizeElement) {
						sizeElement.textContent = sizeText;
						sizeElement.className += ' ' + sizeClass;
					}

					var deleteBtn = item.querySelector('button.delete');
					if (deleteBtn) {
						deleteBtn.onclick = () => {
							selectedFiles.splice(index, 1);
							var fileInput = document.getElementById("attachments");
							var dt = new DataTransfer();
							selectedFiles.forEach((file) => dt.items.add(file));
							fileInput.files = dt.files;
							onAttachments(event);
						};
					}

					container.appendChild(item);
				});

				setTimeout(() => {
					previewArea.scrollIntoView({behavior: "smooth", block: "start"});
				}, 100);
			} else {
				previewArea.style.display = "none";
			}
		}

		function handleDragOver(event) {
			event.preventDefault();
			event.currentTarget.classList.add('drag-over');
		}

		function handleDragLeave(event) {
			event.preventDefault();
			event.currentTarget.classList.remove('drag-over');
		}

		function handleFileDrop(event) {
			event.preventDefault();
			event.currentTarget.classList.remove('drag-over');

			var files = event.dataTransfer.files;
			if (files.length > 0) {
				var fileInput = document.getElementById('attachments');
				if (fileInput) {
					fileInput.files = files;
					onAttachments({ target: fileInput });
				}
			}
		}

		function deleteAttachment(attachmentId) {
			if (!confirm("Sind Sie sicher, dass Sie diesen Anhang l√∂schen m√∂chten?")) {
				return;
			}

			var attachmentItem = document.querySelector('#existing-attachments [data-id="' + attachmentId + '"]');

			if (attachmentItem) {
				attachmentItem.remove();
				existingAttachmentsRemoval.push(attachmentId);
				updateExistingAttachmentsRemoval();

				var existingAttachments = document.getElementById('existing-attachments');
				if (existingAttachments && existingAttachments.children.length === 0) {
					var detailsSection = existingAttachments.closest('details');
					if (detailsSection) {
						detailsSection.style.display = 'none';
					}
				}
			}
		}
	</script>
}

templ hiddenFields(options *PageProps) {
	<input type="hidden" name="type" value={ options.Type }/>
	<input type="hidden" name="id" value={ strconv.FormatInt(options.ID, 10) }/>
	<input type="hidden" name="return_url" value={ string(options.ReturnURL) }/>
	<input type="hidden" name="existing_attachments_removal" id="existing-attachments-removal" value=""/>
}

templ titleInput(title string) {
	<div class="flex flex-col gap-sm w-full">
		<label for="title" class="text-sm text-medium">Titel</label>
		<input
			type="text"
			name="title"
			id="title"
			class="w-full"
			placeholder="Titel eingeben..."
			value={ title }
			required
		/>
	</div>
}

templ markdownToggle(useMarkdown bool) {
	<div class="my">
		<div class="p border muted cursor-pointer transition-all" style="border-radius: var(--ui-radius);">
			<label for="use_markdown" class="flex gap items-center cursor-pointer">
				<input
					type="checkbox"
					name="use_markdown"
					id="use_markdown"
					onchange="toggleMarkdownFeatures()"
					if useMarkdown {
						checked
					}
				/>
				<span class="text-medium w-full">Markdown-Formatierung verwenden</span>
				<div class="ml-auto flex justify-end items-center gap-xs">
					<a
						role="button"
						href={ utils.UrlHelp().MarkdownPage }
						target="_blank"
						class="small primary ghost"
						style="text-wrap: nowrap;"
						title="Vollst√§ndige Markdown Hilfe"
					>
						<i class="bi bi-info-circle"></i>
					</a>
				</div>
			</label>
		</div>
	</div>
}

templ markdownTools() {
	<div id="markdown-tools" class="border p my transition-all" style="display: none; border-radius: var(--ui-radius);">
		<div class="mb text-sm text-semibold flex items-center">
			<span>Markdown-Werkzeuge</span>
		</div>
		<div class="flex gap-sm flex-wrap">
			@markdownToolButton("**", "**", "Fett", "bi-type-bold")
			@markdownToolButton("*", "*", "Kursiv", "bi-type-italic")
			@markdownToolButton("__", "__", "Unterstrichen", "bi-type-underline")
			@markdownToolButton("# ", "", "√úberschrift", "bi-type-h1")
			@markdownToolButton("> ", "", "Zitat", "bi-quote")
			@markdownToolButton("`", "`", "Code", "bi-code")
			@markdownToolButton("- ", "", "Liste", "bi-list-ul")
		</div>
	</div>
}

templ markdownToolButton(before, after, title, iconClass string) {
	<button
		type="button"
		class="icon secondary small"
		onclick={ templ.ComponentScript{
			Call: fmt.Sprintf("insertMarkdown('%s', '%s')", before, after),
		} }
		title={ title }
	>
		<i class={ fmt.Sprintf("bi %s", iconClass) }></i>
	</button>
}

templ contentTextarea(content string) {
	<div class="flex flex-col gap-sm">
		<label for="content" class="text-sm text-medium">Inhalt</label>
		<textarea
			name="content"
			id="content"
			class="w-full resize-y"
			placeholder="Inhalt eingeben..."
			required
			rows="15"
			style="font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; min-height: 400px;"
		>{ content }</textarea>
	</div>
}

templ markdownPreview() {
	<div id="markdown-preview-container" class="my transition-all" style="display: none;">
		<div id="markdown-preview" class="border flex flex-col overflow-hidden" style="height: 400px; border-radius: var(--ui-radius);">
			<div class="px py-sm border-bottom muted flex justify-between items-center text-semibold text-sm">
				<span>Live-Vorschau</span>
				<button type="button" class="secondary small flex gap-sm items-center" onclick="togglePreviewMode()">
					<i class="bi bi-arrows-angle-expand"></i>
					<span id="preview-toggle-text">Vollbild</span>
				</button>
			</div>
			<div id="preview-content" class="p flex-1 overflow-y-auto markdown-content"></div>
		</div>
	</div>
}

templ attachmentsSeparator() {
	<div class="my-lg relative flex items-center justify-center">
		<hr class="w-full"/>
		<div class="absolute px text-lg" style="background: var(--ui-bg);">üìé</div>
	</div>
}

templ attachmentsSection(attachments []*models.Attachment) {
	<div class="border-2 p-lg muted mt transition-all" style="border-radius: var(--ui-radius);">
		@attachmentsSectionHeader()
		if len(attachments) > 0 {
			@existingAttachments(attachments)
		}
		@fileUploadArea()
		@filePreviewArea()
	</div>
}

templ attachmentsSectionHeader() {
	<div class="mb">
		<h3 class="text-lg text-semibold primary ghost flex gap-sm items-center mb">
			<i class="bi bi-paperclip"></i>
			Dateien & Anh√§nge
		</h3>
		<div class="p border-left primary text-sm text-medium muted" style="border-left-width: 4px;">
			Bilder (max. 10MB pro Datei, max. 10 Dateien)
		</div>
	</div>
}

templ existingAttachments(attachments []*models.Attachment) {
	<details class="border mb" style="border-radius: var(--ui-radius);">
		<summary class="p cursor-pointer text-medium flex gap items-center">
			<i class="bi bi-images"></i>
			Vorhandene Bilder ({ len(attachments) })
		</summary>
		<div id="existing-attachments" class="flex flex-col gap mt">
			for attachmentIndex, attachment := range attachments {
				@existingAttachmentItem(attachment, attachmentIndex+1)
			}
		</div>
	</details>
}

templ existingAttachmentItem(attachment *models.Attachment, index int) {
	<div
		class="p border flex gap justify-between items-center"
		data-id={ fmt.Sprintf("%d", attachment.GetID()) }
		style="border-radius: var(--ui-radius);"
	>
		<div class="flex gap items-center">
			<span class="text-medium">Anhang { index }</span>
			<span class="muted text-sm">({ attachment.GetMimeType() })</span>
		</div>
		<div class="flex gap-sm">
			<button
				type="button"
				class="secondary small"
				onclick={ components.OpenImageViewer(
					utils.UrlTroubleReports(0, attachment.GetID(), 0).Attachment,
				) }
			>
				<i class="bi bi-eye"></i>
				Anzeigen
			</button>
			<button
				type="button"
				class="destructive small"
				onclick={ deleteAttachment(attachment.GetID()) }
			>
				<i class="bi bi-trash"></i>
				L√∂schen
			</button>
		</div>
	</div>
}

templ fileUploadArea() {
	<div
		class="border-2 border-dashed p-xl text-center cursor-pointer transition-all mb"
		onclick='document.getElementById("attachments").click();'
		ondrop="handleFileDrop(event)"
		ondragover="handleDragOver(event)"
		ondragleave="handleDragLeave(event)"
		style="border-radius: var(--ui-radius);"
	>
		<i class="bi bi-cloud-upload text-2xl mb-sm"></i>
		<div class="text-medium mb-sm">Bilder hochladen</div>
		<div class="text-sm opacity-75">Klicken oder Dateien hierher ziehen</div>
		<input
			type="file"
			name="attachments"
			id="attachments"
			multiple
			accept="image/*"
			onchange="onAttachments(event)"
			class="hidden"
		/>
	</div>
}

templ filePreviewArea() {
	<div id="file-preview" class="border p" style="display: none; border-radius: var(--ui-radius);">
		<div class="mb text-medium">
			<span>Neue Bilder:</span>
		</div>
		<div id="new-attachments" class="flex flex-col gap"></div>
		<template name="attachment-item">
			<div class="p border flex gap justify-between items-center" style="border-radius: var(--ui-radius);">
				<div class="flex gap items-center">
					<span class="attachment-name name text-medium"></span>
					<span class="attachment-size size-text text-sm muted"></span>
				</div>
				<div>
					<button type="button" class="delete destructive small">
						<i class="bi bi-trash"></i>
						Entfernen
					</button>
				</div>
			</div>
		</template>
	</div>
}

templ formActions(options *PageProps) {
	<div class="mt-lg pt border-top flex gap justify-end">
		if options.ReturnURL != "" {
			<a
				role="button"
				href={ options.ReturnURL }
				class="secondary flex gap-sm items-center"
			>
				<i class="bi bi-x-circle"></i>
				Abbrechen
			</a>
		}
		<button type="submit" class="primary flex gap-sm items-center">
			if options.ID > 0 {
				<i class="bi bi-check-circle"></i>
				Aktualisieren
			} else {
				<i class="bi bi-plus-circle"></i>
				Erstellen
			}
		</button>
	</div>
}

func getTypeName(editorType models.EditorType) string {
	switch editorType {
	case models.TypeTroubleReport:
		return "Problembericht"
	default:
		return "Dokument"
	}
}

func supportsAttachments(editorType models.EditorType) bool {
	return editorType == models.TypeTroubleReport
}

script deleteAttachment(attachmentId models.AttachmentID) {
	deleteAttachment(attachmentId);
}
