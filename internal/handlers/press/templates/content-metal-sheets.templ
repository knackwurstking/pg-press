package templates

import (
	"fmt"
	"github.com/knackwurstking/pg-press/components"
	"github.com/knackwurstking/pg-press/models"
)

templ MetalSheetsSection(press models.PressNumber, toolsMap map[models.ToolID]*models.Tool, metalSheets []*models.MetalSheet) {
	{{ expectedMachineType := models.GetMachineTypeForPress(press) }}
	<div class="flex flex-col gap-sm">
		<div class="text-center">
			<small class="text-muted">
				Zeigt nur Bleche für { expectedMachineType.DisplayName() }
				(Presse { fmt.Sprintf("%d", press) })
			</small>
		</div>
		@metalSheetTablesCollapsible(metalSheets, toolsMap)
	</div>
}

// Metal sheet table components
templ metalSheetTablesCollapsible(metalSheets []*models.MetalSheet, toolsMap map[models.ToolID]*models.Tool) {
	@metalSheetTableTopCollapsible(metalSheets, toolsMap)
	<br/>
	@metalSheetTableBottomCollapsible(metalSheets, toolsMap)
}

templ metalSheetTableTopCollapsible(metalSheets []*models.MetalSheet, toolsMap map[models.ToolID]*models.Tool) {
	{{
		topSheets := filterMetalSheetsByPosition(
			metalSheets,
			toolsMap,
			[]models.Position{
				models.PositionTop,
				models.PositionTopCassette,
			},
		)
	}}
	<details
		class="mb"
		if len(topSheets) > 0 {
			open
		}
	>
		<summary class="cursor-pointer select-none">
			<h6 class="inline">Oberteil / Kassette ({ fmt.Sprintf("%d", len(topSheets)) } Einträge)</h6>
		</summary>
		<div class="mt">
			<figure class="w-full overflow-x-scroll">
				<table class="table borderless compact">
					<thead>
						<tr>
							<th>Stärke (mm)</th>
							<th>Blech (mm)</th>
						</tr>
					</thead>
					<tbody>
						if len(topSheets) == 0 {
							<tr>
								<td colspan="2" class="text-center">
									@components.NotFoundSectionText("Keine Bleche für Oberteil gefunden")
								</td>
							</tr>
						} else {
							for _, sheet := range topSheets {
								<tr>
									<td>{ fmt.Sprintf("%.1f", sheet.TileHeight) }</td>
									<td>{ fmt.Sprintf("%.1f", sheet.Value) }</td>
								</tr>
							}
						}
					</tbody>
				</table>
			</figure>
		</div>
	</details>
}

templ metalSheetTableBottomCollapsible(metalSheets []*models.MetalSheet, toolsMap map[models.ToolID]*models.Tool) {
	{{ bottomSheets := filterMetalSheetsByPosition(metalSheets, toolsMap, []models.Position{models.PositionBottom}) }}
	<details
		class="mb"
		if len(bottomSheets) > 0 {
			open
		}
	>
		<summary class="cursor-pointer select-none">
			<h6 class="inline">Unterteil ({ fmt.Sprintf("%d", len(bottomSheets)) } Einträge)</h6>
		</summary>
		<div class="mt">
			<figure class="w-full overflow-x-scroll">
				<table class="table borderless compact">
					<thead>
						<tr>
							<th>Stärke (mm)</th>
							<th>Blech (mm)</th>
							<th>Marke (mm)</th>
							<th>Stf.</th>
							<th>Hubende</th>
						</tr>
					</thead>
					<tbody>
						if len(bottomSheets) == 0 {
							<tr>
								<td colspan="5" class="text-center">
									@components.NotFoundSectionText("Keine Bleche für Unterteil gefunden")
								</td>
							</tr>
						} else {
							for _, sheet := range bottomSheets {
								<tr>
									<td>{ fmt.Sprintf("%.1f", sheet.TileHeight) }</td>
									<td>{ fmt.Sprintf("%.1f", sheet.Value) }</td>
									<td>
										if sheet.MarkeHeight > 0 {
											{ fmt.Sprintf("%d", sheet.MarkeHeight) }
										} else {
											<span class="text-muted">-</span>
										}
									</td>
									<td>
										if sheet.STF > 0 {
											{ fmt.Sprintf("%.1f", sheet.STF) }
										} else {
											<span class="text-muted">-</span>
										}
									</td>
									<td>
										if sheet.STFMax > 0 {
											{ fmt.Sprintf("%.1f", sheet.STFMax) }
										} else {
											<span class="text-muted">-</span>
										}
									</td>
								</tr>
							}
						}
					</tbody>
				</table>
			</figure>
		</div>
	</details>
}

func filterMetalSheetsByPosition(
	metalSheets []*models.MetalSheet, toolsMap map[models.ToolID]*models.Tool, positions []models.Position,
) []*models.MetalSheet {
	var filtered models.MetalSheetList
	for _, sheet := range metalSheets {
		if tool, exists := toolsMap[sheet.ToolID]; exists && tool != nil {
			for _, pos := range positions {
				if tool.Position == pos {
					filtered = append(filtered, sheet)
					break
				}
			}
		}
	}
	return filtered.Sort()
}
