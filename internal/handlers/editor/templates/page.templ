package templates

import (
	"fmt"

	"github.com/knackwurstking/pg-press/internal/components"
	"github.com/knackwurstking/pg-press/internal/shared"
	"github.com/knackwurstking/pg-press/internal/urlb"
	"github.com/knackwurstking/ui/pkg/css"
)

type PageProps struct {
	Type        shared.EditorType
	ID          shared.EntityID
	ReturnURL   templ.SafeURL
	Title       string
	Content     string
	Attachments []string
	UseMarkdown bool
}

templ Page(props *PageProps) {
	{{
		var pageTitle, editorTitle string
		typeName := getTypeName(props.Type)

		if props.ID > 0 {
			pageTitle = fmt.Sprintf("Bearbeiten - %s", typeName)
			editorTitle = fmt.Sprintf("%s bearbeiten", typeName)
		} else {
			pageTitle = fmt.Sprintf("Erstellen - %s", typeName)
			editorTitle = fmt.Sprintf("Neues %s erstellen", typeName)
		}
	}}
	@components.Layout(components.LayoutProps{
		PageTitle:      pageTitle,
		AppBarTitle:    editorTitle,
		AdditionalHead: pageAdditionalHead(),
		NavContent:     pageNavContent(props),
	}) {
		<main class={ css.Container, css.ContainerFluid }>
			<div class="editor-container">
				<form
					class={ "editor-form", css.Flex, css.FlexCol, css.Gap, css.PX }
					method="POST"
					action={ urlb.EditorSave() }
					enctype="multipart/form-data"
				>
					@hiddenFields(props)
					@titleInput(props.Title)
					@markdownToggle(props.UseMarkdown)
					@contentTextarea(props.Content)
					@markdownPreview()
					if supportsAttachments(props.Type) {
						@attachmentsSeparator()
						@attachmentsSection(props.Attachments)
					}
					@formActions(props)
				</form>
			</div>
		</main>
		@components.MarkdownScript()
	}
}

templ pageNavContent(props *PageProps) {
	if props.ReturnURL != "" {
		<a href={ props.ReturnURL } class={ css.Secondary, css.Flex, css.Gap }>
			<i class="bi bi-arrow-left"></i>
			Zur√ºck
		</a>
	}
}

templ pageAdditionalHead() {
	@components.MarkdownStyles()
	<style>
		.markdown-content h1,
		.markdown-content h2,
		.markdown-content h3,
		.markdown-content h4,
		.markdown-content h5,
		.markdown-content h6 {
			margin: 0.8em 0 0.4em 0;
			font-weight: bold;
			line-height: 1.3;
		}

		.markdown-content h1 { font-size: 1.4em; }
		.markdown-content h2 { font-size: 1.2em; }
		.markdown-content h3 { font-size: 1.1em; }

		.markdown-content p {
			margin: 0.5em 0 1em 0;
		}

		.markdown-content ul,
		.markdown-content ol {
			margin: 0.5em 0;
			padding-left: 1.5em;
			list-style: inherit;
		}

		.markdown-content ul { list-style-type: disc; }
		.markdown-content ol { list-style-type: decimal; }

		.markdown-content li {
			margin: 0.25em 0;
			display: list-item;
		}

		.markdown-content code {
			font-size: 0.85em;
			padding: 0.125em 0.25em;
			border-radius: 2px;
		}

		.markdown-content strong { font-weight: 600; }
		.markdown-content em { font-style: italic; }

		@media (max-width: 768px) {
			#markdown-preview { min-height: 200px; }
			.flex-wrap { justify-content: center; }
		}

		.transition-all:hover { border-color: var(--ui-primary); }
		.border-2:hover {
			border-color: var(--ui-primary);
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
		}

		.file-upload-area:hover,
		.file-upload-area.drag-over { border-color: var(--ui-primary); }

		.preview-fullscreen textarea { display: none; }
		.preview-fullscreen #markdown-preview { min-height: 600px; }
	</style>
	<script>
		var selectedFiles = [];
		var existingAttachmentsRemoval = [];
		var isPreviewFullscreen = false;

		document.addEventListener('DOMContentLoaded', initializeMarkdownFeatures);

		function initializeMarkdownFeatures() {
			var checkbox = document.getElementById('use_markdown');
			if (checkbox) {
				toggleMarkdownFeatures();
			}
		}

		function toggleMarkdownFeatures() {
			var checkbox = document.getElementById('use_markdown');
			var previewContainer = document.getElementById('markdown-preview-container');
			var textarea = document.getElementById('content');

			if (checkbox.checked) {
				previewContainer.style.display = 'block';
				textarea.setAttribute('placeholder', 'Inhalt (Markdown-Formatierung aktiviert)');
				updatePreview();
				textarea.addEventListener('input', updatePreview);
			} else {
				previewContainer.style.display = 'none';
				textarea.removeEventListener('input', updatePreview);
				textarea.setAttribute('placeholder', 'Inhalt');
			}
		}

		function updatePreview() {
			window.updateMarkdownPreview('content', 'preview-content');
		}

		function togglePreviewMode() {
			var container = document.querySelector('.editor-container');
			var toggleText = document.getElementById('preview-toggle-text');
			var toggleIcon = document.querySelector('#markdown-preview button i');

			isPreviewFullscreen = !isPreviewFullscreen;

			if (isPreviewFullscreen) {
				container.classList.add('preview-fullscreen');
				toggleText.textContent = 'Split';
				toggleIcon.className = 'bi bi-arrows-angle-contract';
			} else {
				container.classList.remove('preview-fullscreen');
				toggleText.textContent = 'Vollbild';
				toggleIcon.className = 'bi bi-arrows-angle-expand';
			}
		}

		function insertMarkdown(before, after) {
			var textarea = document.getElementById('content');
			if (!textarea) return;

			var start = textarea.selectionStart;
			var end = textarea.selectionEnd;
			var selectedText = textarea.value.substring(start, end);
			var newText = before + selectedText + after;

			textarea.value = textarea.value.substring(0, start) + newText + textarea.value.substring(end);

			var newPos = selectedText === '' ? start + before.length : start + before.length + selectedText.length + after.length;

			textarea.focus();
			textarea.setSelectionRange(newPos, newPos);
			updatePreview();
		}

		function updateExistingAttachmentsRemoval() {
			var input = document.getElementById('existing-attachments-removal');
			if (input) {
				input.value = existingAttachmentsRemoval.join(',');
			}
		}

		function formatFileSize(bytes) {
			if (bytes === 0) return "0 Bytes";
			var k = 1024;
			var sizes = ["Bytes", "KB", "MB", "GB"];
			var i = Math.floor(Math.log(bytes) / Math.log(k));
			return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
		}

		function onAttachments(event) {
			selectedFiles = Array.from(event.target.files);
			var previewArea = document.getElementById("file-preview");
			var container = document.getElementById("new-attachments");

			if (!previewArea || !container) return;

			container.innerHTML = "";

			if (selectedFiles.length > 0) {
				previewArea.style.display = "block";

				selectedFiles.forEach((file, index) => {
					var sizeClass = file.size > 10 * 1024 * 1024 ? "attachment-error text-red" : "muted text-sm";
					var sizeText = file.size > 10 * 1024 * 1024 ? "ZU GROSS!" : formatFileSize(file.size);

					var template = previewArea.querySelector('template[name="attachment-item"]');
					if (!template) return;

					var item = template.content.cloneNode(true);

					var nameElement = item.querySelector('.name');
					if (nameElement) nameElement.textContent = file.name;

					var sizeElement = item.querySelector('.size-text');
					if (sizeElement) {
						sizeElement.textContent = sizeText;
						sizeElement.className += ' ' + sizeClass;
					}

					var deleteBtn = item.querySelector('button.delete');
					if (deleteBtn) {
						deleteBtn.onclick = () => {
							selectedFiles.splice(index, 1);
							var fileInput = document.getElementById("attachments");
							var dt = new DataTransfer();
							selectedFiles.forEach((file) => dt.items.add(file));
							fileInput.files = dt.files;
							onAttachments(event);
						};
					}

					container.appendChild(item);
				});

				setTimeout(() => {
					previewArea.scrollIntoView({behavior: "smooth", block: "start"});
				}, 100);
			} else {
				previewArea.style.display = "none";
			}
		}

		function handleDragOver(event) {
			event.preventDefault();
			event.currentTarget.classList.add('drag-over');
		}

		function handleDragLeave(event) {
			event.preventDefault();
			event.currentTarget.classList.remove('drag-over');
		}

		function handleFileDrop(event) {
			event.preventDefault();
			event.currentTarget.classList.remove('drag-over');

			var files = event.dataTransfer.files;
			if (files.length > 0) {
				var fileInput = document.getElementById('attachments');
				if (fileInput) {
					fileInput.files = files;
					onAttachments({ target: fileInput });
				}
			}
		}

		function deleteAttachment(attachment) {
			if (!confirm("Sind Sie sicher, dass Sie diesen Anhang l√∂schen m√∂chten?")) {
				return;
			}

			var attachmentItem = document.querySelector('#existing-attachments [data-attachment-path="' + attachment + '"]');

			if (attachmentItem) {
				attachmentItem.remove();
				existingAttachmentsRemoval.push(attachment);
				updateExistingAttachmentsRemoval();

				var existingAttachments = document.getElementById('existing-attachments');
				if (existingAttachments && existingAttachments.children.length === 0) {
					var detailsSection = existingAttachments.closest('details');
					if (detailsSection) {
						detailsSection.style.display = 'none';
					}
				}
			}
		}
	</script>
}

templ hiddenFields(options *PageProps) {
	<input type="hidden" name="type" value={ options.Type }/>
	<input type="hidden" name="id" value={ options.ID }/>
	<input type="hidden" name="return_url" value={ string(options.ReturnURL) }/>
	<input type="hidden" name="existing_attachments_removal" id="existing-attachments-removal" value=""/>
}

templ titleInput(title string) {
	<div class={ css.Flex, css.FlexCol, css.GapSm, css.WFull }>
		<label for="title" class={ css.TextSM, css.TextMedium }>Titel</label>
		<input
			type="text"
			name="title"
			id="title"
			class={ css.WFull }
			placeholder="Titel eingeben..."
			value={ title }
			required
		/>
	</div>
}

templ markdownToggle(useMarkdown bool) {
	<div class={ css.MY }>
		<div
			class={ css.P, css.Border, css.Muted, css.CursorPointer, css.TransitionAll }
			style={ fmt.Sprintf("border-radius: %s", css.VarRadius) }
		>
			<label
				for="use_markdown"
				class={ css.Flex, css.Gap, css.ItemsCenter, css.CursorPointer }
			>
				<input
					type="checkbox"
					name="use_markdown"
					id="use_markdown"
					onchange="toggleMarkdownFeatures()"
					if useMarkdown {
						checked
					}
				/>
				<span class={ css.TextMedium, css.WFull }>Markdown-Formatierung verwenden</span>
			</label>
		</div>
	</div>
}

templ contentTextarea(content string) {
	<div class={ css.Flex, css.FlexCol, css.GapSm }>
		<label for="content" class={ css.TextSM, css.TextMedium }>Inhalt</label>
		<textarea
			name="content"
			id="content"
			class={ css.WFull, css.ResizeY }
			placeholder="Inhalt eingeben..."
			required
			rows="15"
			style="font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; min-height: 400px;"
		>{ content }</textarea>
	</div>
}

templ markdownPreview() {
	<div id="markdown-preview-container" class={ css.MY, css.TransitionAll } style="display: none;">
		<div
			id="markdown-preview"
			class={ css.Border, css.Flex, css.FlexCol, css.OverflowHidden }
			style={ fmt.Sprintf("height: 400px; border-radius: %s;", css.VarRadius) }
		>
			<div
				class={ css.PX, css.PYSm, 
					css.BorderBottom, 
					css.Muted, 
					css.Flex, css.JustifyBetween, css.ItemsCenter, 
					css.TextSemibold, css.TextSM }
			>
				<span>Live-Vorschau</span>
				<button
					type="button"
					class={ css.Secondary, css.ButtonSmall, css.Flex, css.GapSm, css.ItemsCenter }
					onclick="togglePreviewMode()"
				>
					<i class="bi bi-arrows-angle-expand"></i>
					<span id="preview-toggle-text">Vollbild</span>
				</button>
			</div>
			<div id="preview-content" class={ "markdown-content", css.P, css.Flex1, css.OverflowYAuto }></div>
		</div>
	</div>
}

templ attachmentsSeparator() {
	<div class={ css.MYLg, css.Relative, css.Flex, css.ItemsCenter, css.JustifyCenter }>
		<hr class={ css.WFull }/>
		<div class={ css.Absolute, css.PX, css.TextLG } style={ fmt.Sprintf("background: %s;", css.VarBg) }>üìé</div>
	</div>
}

templ attachmentsSection(attachments []string) {
	<div
		class={ css.Border, css.PLg, css.Muted, css.MT, css.TransitionAll }
		style={ fmt.Sprintf("border-radius: %s;", css.VarRadius) }
	>
		@attachmentsSectionHeader()
		if len(attachments) > 0 {
			@existingAttachments(attachments)
		}
		@fileUploadArea()
		@filePreviewArea()
	</div>
}

templ attachmentsSectionHeader() {
	<div class={ css.MB }>
		<h3
			class={ css.TextLG, css.TextSemibold, css.Primary, css.Ghost, css.Flex, css.GapSm, css.ItemsCenter, css.MB }
		>
			<i class="bi bi-paperclip"></i>
			Dateien & Anh√§nge
		</h3>
		<div
			class={ css.P, css.BorderLeft, css.Primary, css.TextSM, css.TextMedium, css.Muted }
			style="border-left-width: 4px;"
		>
			Bilder (max. 10MB pro Datei, max. 10 Dateien)
		</div>
	</div>
}

templ existingAttachments(attachments []string) {
	<details class={ css.Border, css.MB } style={ fmt.Sprintf("border-radius: %s;", css.VarRadius) }>
		<summary class={ css.P, css.CursorPointer, css.TextMedium, css.Flex, css.Gap, css.ItemsCenter }>
			<i class="bi bi-images"></i>
			Vorhandene Bilder ({ len(attachments) })
		</summary>
		<div id="existing-attachments" class={ css.Flex, css.FlexCol, css.Gap, css.MT }>
			for attachmentIndex, attachment := range attachments {
				@existingAttachmentItem(attachment, attachmentIndex+1)
			}
		</div>
	</details>
}

templ existingAttachmentItem(attachment string, index int) {
	<div
		class={ css.P, css.Border, css.Flex, css.Gap, css.JustifyBetween, css.ItemsCenter }
		data-attachment-path={ attachment }
		style={ fmt.Sprintf("border-radius: %s", css.VarRadius) }
	>
		<div class={ css.Flex, css.Gap, css.ItemsCenter }>
			<span class={ css.TextMedium }>Anhang { index }</span>
			<span class={ css.Muted, css.TextSM }>({ attachment })</span>
		</div>
		<div class={ css.Flex, css.GapSm }>
			<button
				type="button"
				class={ css.Secondary, css.ButtonSmall }
				onclick={ components.OpenImageViewer(urlb.Attachment(attachment)) }
			>
				<i class="bi bi-eye"></i>
				Anzeigen
			</button>
			<button
				type="button"
				class={ css.Destructive, css.ButtonSmall }
				onclick={ deleteAttachment(attachment) }
			>
				<i class="bi bi-trash"></i>
				L√∂schen
			</button>
		</div>
	</div>
}

templ fileUploadArea() {
	<div
		class={ css.Border, css.PXl, css.TextCenter, css.CursorPointer, css.TransitionAll, css.MB }
		onclick='document.getElementById("attachments").click();'
		ondrop="handleFileDrop(event)"
		ondragover="handleDragOver(event)"
		ondragleave="handleDragLeave(event)"
		style={ fmt.Sprintf("border-radius: %s;", css.VarRadius) }
	>
		<i class={ "bi", "bi-cloud-upload", css.Text2XL, css.MB }></i>
		<div class={ css.TextMedium, css.MB }>Bilder hochladen</div>
		<div class={ css.TextSM, css.Opacity75 }>Klicken oder Dateien hierher ziehen</div>
		<input
			type="file"
			name="attachments"
			id="attachments"
			multiple
			accept="image/*"
			onchange="onAttachments(event)"
			class={ css.Hidden }
		/>
	</div>
}

templ filePreviewArea() {
	<div
		id="file-preview"
		class={ css.Border, css.P }
		style={ fmt.Sprintf("display: none; border-radius: %s", css.VarRadius) }
	>
		<div class={ css.MB, css.TextMedium }>
			<span>Neue Bilder:</span>
		</div>
		<div id="new-attachments" class={ css.Flex, css.FlexCol, css.Gap }></div>
		<template name="attachment-item">
			<div
				class={ css.P, css.Border, css.Flex, css.Gap, css.JustifyBetween, css.ItemsCenter }
				style={ fmt.Sprintf("border-radius: %s", css.VarRadius) }
			>
				<div class={ css.Flex, css.Gap, css.ItemsCenter }>
					<span class={ "attachment-name", "name", css.TextMedium }></span>
					<span class={ "attachment-size", "size-text", css.TextSM, css.Muted }></span>
				</div>
				<div>
					<button type="button" class={ css.Destructive, css.ButtonSmall, css.Flex, css.Gap }>
						<i class="bi bi-trash"></i>
						Entfernen
					</button>
				</div>
			</div>
		</template>
	</div>
}

templ formActions(options *PageProps) {
	<div class={ css.MT, css.PT, css.BorderTop, css.Flex, css.Gap, css.JustifyEnd }>
		if options.ReturnURL != "" {
			<a
				role="button"
				href={ options.ReturnURL }
				class={ css.Secondary, css.Flex, css.GapSm, css.ItemsCenter }
			>
				<i class="bi bi-x-circle"></i>
				Abbrechen
			</a>
		}
		<button type="submit" class={ css.Primary, css.Flex, css.GapSm, css.ItemsCenter }>
			if options.ID > 0 {
				<i class="bi bi-check-circle"></i>
				Aktualisieren
			} else {
				<i class="bi bi-plus-circle"></i>
				Erstellen
			}
		</button>
	</div>
}

func getTypeName(editorType shared.EditorType) string {
	switch editorType {
	case shared.EditorTypeTroubleReport:
		return "Problembericht"
	default:
		return "Dokument"
	}
}

func supportsAttachments(editorType shared.EditorType) bool {
	return editorType == shared.EditorTypeTroubleReport
}

script deleteAttachment(attachment string) {
	deleteAttachment(attachment);
}
