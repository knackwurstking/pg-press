package templates

import (
	"fmt"

	"github.com/knackwurstking/pg-press/internal/components"
	"github.com/knackwurstking/pg-press/internal/components/accordion"
	"github.com/knackwurstking/pg-press/internal/components/button"
	"github.com/knackwurstking/pg-press/internal/components/checkbox"
	"github.com/knackwurstking/pg-press/internal/components/form"
	"github.com/knackwurstking/pg-press/internal/components/icon"
	"github.com/knackwurstking/pg-press/internal/components/input"
	"github.com/knackwurstking/pg-press/internal/components/textarea"
	"github.com/knackwurstking/pg-press/internal/env"
	"github.com/knackwurstking/pg-press/internal/shared"
	"github.com/knackwurstking/pg-press/internal/urlb"
	uicomponents "github.com/knackwurstking/ui/pkg/components"
	"github.com/knackwurstking/ui/pkg/css"
	"github.com/knackwurstking/ui/pkg/ui"
)

type PageProps struct {
	Type        shared.EditorType
	ID          shared.EntityID
	ReturnURL   templ.SafeURL
	Title       string
	Content     string
	Attachments []string
	UseMarkdown bool
}

templ Page(props *PageProps) {
	{{
		var pageTitle, editorTitle string
		typeName := getTypeName(props.Type)

		if props.ID > 0 {
			pageTitle = fmt.Sprintf("Bearbeiten - %s", typeName)
			editorTitle = fmt.Sprintf("%s bearbeiten", typeName)
		} else {
			pageTitle = fmt.Sprintf("Erstellen - %s", typeName)
			editorTitle = fmt.Sprintf("Neues %s erstellen", typeName)
		}
	}}
	@components.Layout(components.LayoutProps{
		PageTitle:      pageTitle,
		AppBarTitle:    editorTitle,
		AdditionalHead: pageAdditionalHead(),
		NavContent:     pageNavContent(props),
	}) {
		<main class="mt-8 p-8">
			<div class="editor-container">
				<form
					class="editor-form flex flex-col gap-6 px-4"
					method="POST"
					action={ urlb.EditorSave() }
					enctype="multipart/form-data"
				>
					@hiddenFields(props)
					@titleInput(props.Title)
					@markdownToggle(props.UseMarkdown)
					@contentTextarea(props.Content)
					@markdownPreview()
					if supportsAttachments(props.Type) {
						@attachmentsSeparator()
						@attachmentsSection(props.Attachments)
					}
					@formActions(props)
				</form>
			</div>
		</main>
		@uicomponents.MarkdownScript()
	}
}

templ pageNavContent(props *PageProps) {
	if props.ReturnURL != "" {
		@button.Button(button.Props{
			Variant: button.VariantSecondary,
			Href:    string(props.ReturnURL),
		}) {
			@icon.ArrowLeft()
			ZurÃ¼ck
		}
	}
}

templ pageAdditionalHead() {
	<script defer src={ ui.AssetURL(env.ServerPathPrefix, "/js/editor/main.js") }></script>
}

templ hiddenFields(options *PageProps) {
	<input type="hidden" id="type" name="type" value={ options.Type }/>
	<input type="hidden" id="id" name="id" value={ options.ID }/>
	<input type="hidden" id="return_url" name="return_url" value={ string(options.ReturnURL) }/>
	<input type="hidden" id="existing-attachments-removal" name="existing_attachments_removal" value=""/>
}

templ titleInput(title string) {
	@form.Item() {
		@form.Label(form.LabelProps{
			For: "title",
		}) {
			Titel	
		}
		@input.Input(input.Props{
			ID:          "title",
			Class:       "w-full",
			Name:        "title",
			Type:        input.TypeText,
			Placeholder: "Titel eingeben...",
			Value:       title,
			Attributes: templ.Attributes{
				"required": true,
			},
		})
	}
}

templ markdownToggle(useMarkdown bool) {
	@form.ItemFlex(form.ItemProps{
		Class: "p-4 text-muted-foreground bg-muted rounded border transition",
	}) {
		@checkbox.Checkbox(checkbox.Props{
			ID:      "use_markdown",
			Name:    "use_markdown",
			Checked: useMarkdown,
			Attributes: templ.Attributes{
				"onchange": "toggleMarkdownFeatures()",
			},
		})
		@form.Label(form.LabelProps{
			Class: "cursor-pointer",
			For:   "use_markdown",
		}) {
			Markdown-Formatierung verwenden
		}
	}
}

templ contentTextarea(content string) {
	@form.Item() {
		@form.Label(form.LabelProps{
			For: "content",
		}) {
			Inhalt
		}
		@textarea.Textarea(textarea.Props{
			ID:          "content",
			Class:       "w-full",
			Name:        "content",
			Placeholder: "Inhalt eingeben...",
			Value:       content,
			Rows:        15,
			AutoResize:  false,
			Attributes: templ.Attributes{
				"required": true,
			},
		})
	}
}

templ markdownPreview() {
	<div id="markdown-preview-container" class="hidden">
		<div
			id="markdown-preview"
			class="border flex flex-col overfow-hidden h-auto max-h-150 rounded"
		>
			<div class="p-2 border-b bg-muted text-muted-foreground font-semibold text-sm">
				<span>Live-Vorschau</span>
			</div>
			<div id="preview-content" class="markdown-content p flex-1 overflow-y-auto"></div>
		</div>
	</div>
}

templ attachmentsSeparator() {
	<div class="relative flex items-center justify-center">
		<hr class="w-full"/>
		<div class="absolute text-lg bg-background">ðŸ“Ž</div>
	</div>
}

templ attachmentsSection(attachments []string) {
	<div class="border p-6 rounded bg-muted text-muted-foreground transition">
		@attachmentsSectionHeader()
		if len(attachments) > 0 {
			@existingAttachments(attachments)
		}
		@fileUploadArea()
		@filePreviewArea()
	</div>
}

templ attachmentsSectionHeader() {
	<div>
		<h3
			class="text-lg font-semibold text-primary flex gap-2 items-center mb-2"
		>
			@icon.Paperclip()
			Dateien & AnhÃ¤nge
		</h3>
		<div class="p-4 border-l bg-primary text-primary-foreground rounded text-sm my-2">
			Bilder (max. 10MB pro Datei, max. 10 Dateien)
		</div>
	</div>
}

templ existingAttachments(attachments []string) {
	@accordion.Accordion() {
		@accordion.Item() {
			@accordion.Trigger() {
				@icon.Images()
				Vorhandene Bilder ({ len(attachments) })
			}
			@accordion.Content(accordion.ContentProps{
				ID:    "existing-attachments",
				Class: "space-y-2",
			}) {
				for attachmentIndex, attachment := range attachments {
					@existingAttachmentItem(attachment, attachmentIndex+1)
				}
			}
		}
	}
}

templ existingAttachmentItem(attachment string, index int) {
	<div
		class="p-2 border flex flex-wrap gap-4 justify-between items-center rounded"
		data-attachment-path={ attachment }
	>
		<div class="flex flex-col items-start justify-center">
			<span class="font-bold text-base">Anhang { index }</span>
			<span class="bg-muted text-muted-foreground text-sm truncate">{ attachment }</span>
		</div>
		<div class="flex gap-2">
			@button.Button(button.Props{
				Variant: button.VariantGhost,
				Size:    button.SizeSm,
				Attributes: templ.Attributes{
					"onclick": fmt.Sprintf(`openImageViewer("%s")`, urlb.Attachment(attachment)),
				},
			}) {
				@icon.Eye()
				Anzeigen
			}
			@button.Button(button.Props{
				Variant: button.VariantDestructive,
				Size:    button.SizeSm,
				Attributes: templ.Attributes{
					"onclick": fmt.Sprintf(`deleteAttachment("%s")`, attachment),
				},
			}) {
				@icon.Trash()
				LÃ¶schen
			}
		</div>
	</div>
}

templ fileUploadArea() {
	<div
		class="border rounded text-center cursor-pointer p-4 my-2 flex flex-col justify-center items-center gap-2"
		onclick='document.getElementById("attachments").click();'
		ondrop="handleFileDrop(event)"
		ondragover="handleDragOver(event)"
		ondragleave="handleDragLeave(event)"
	>
		@icon.CloudUpload()
		<div class={ css.TextMedium, css.MB }>Bilder hochladen</div>
		<div class="text-sm opacity-75">Klicken oder Dateien hierher ziehen</div>
		@input.Input(input.Props{
			ID:    "attachments",
			Class: "hidden",
			Name:  "attachments",
			Type:  input.TypeFile,
			Attributes: templ.Attributes{
				"multiple": true,
				"accept":   "image/*",
				"onchange": "onAttachments(event)",
			},
		})
	</div>
}

templ filePreviewArea() {
	<div
		id="file-preview"
		class="border rounded p-2"
	>
		<div>
			<span class="text-lg">Neue Bilder:</span>
		</div>
		<div id="new-attachments" class="flex flex-col"></div>
		<template name="attachment-item">
			<div class="p-2 my-2 border rounded flex gap-4 justify-between items-center">
				<div class="flex gap-4 items-center">
					<span class="attachment-name name text-base"></span>
					<span class="attachment-size size-text text-sm"></span>
				</div>
				<div>
					@button.Button(button.Props{
						Class:   "delete",
						Variant: button.VariantDestructive,
						Size:    button.SizeSm,
					}) {
						@icon.Trash()
						Entfernen
					}
				</div>
			</div>
		</template>
	</div>
}

templ formActions(options *PageProps) {
	<div class="border-t flex gap-4 justify-end p-4">
		@button.Button(button.Props{
			Type: button.TypeSubmit,
		}) {
			if options.ID > 0 {
				@icon.CircleCheck()
				Aktualisieren
			} else {
				@icon.CirclePlus()
				Erstellen
			}
		}
	</div>
}

func getTypeName(editorType shared.EditorType) string {
	switch editorType {
	case shared.EditorTypeTroubleReport:
		return "Problembericht"
	default:
		return "Dokument"
	}
}

func supportsAttachments(editorType shared.EditorType) bool {
	return editorType == shared.EditorTypeTroubleReport
}
