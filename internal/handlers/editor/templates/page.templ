package templates

import (
	"fmt"

	"github.com/knackwurstking/pg-press/internal/components"
	"github.com/knackwurstking/pg-press/internal/components/button"
	"github.com/knackwurstking/pg-press/internal/components/checkbox"
	"github.com/knackwurstking/pg-press/internal/components/form"
	"github.com/knackwurstking/pg-press/internal/components/icon"
	"github.com/knackwurstking/pg-press/internal/components/input"
	"github.com/knackwurstking/pg-press/internal/components/textarea"
	"github.com/knackwurstking/pg-press/internal/env"
	"github.com/knackwurstking/pg-press/internal/shared"
	"github.com/knackwurstking/pg-press/internal/urlb"
	uicomponents "github.com/knackwurstking/ui/pkg/components"
	"github.com/knackwurstking/ui/pkg/css"
	"github.com/knackwurstking/ui/pkg/ui"
)

type PageProps struct {
	Type        shared.EditorType
	ID          shared.EntityID
	ReturnURL   templ.SafeURL
	Title       string
	Content     string
	Attachments []string
	UseMarkdown bool
}

templ Page(props *PageProps) {
	{{
		var pageTitle, editorTitle string
		typeName := getTypeName(props.Type)

		if props.ID > 0 {
			pageTitle = fmt.Sprintf("Bearbeiten - %s", typeName)
			editorTitle = fmt.Sprintf("%s bearbeiten", typeName)
		} else {
			pageTitle = fmt.Sprintf("Erstellen - %s", typeName)
			editorTitle = fmt.Sprintf("Neues %s erstellen", typeName)
		}
	}}
	@components.Layout(components.LayoutProps{
		PageTitle:      pageTitle,
		AppBarTitle:    editorTitle,
		AdditionalHead: pageAdditionalHead(),
		NavContent:     pageNavContent(props),
	}) {
		<main class="mt-8 p-8">
			<div class="editor-container">
				<form
					class="editor-form flex flex-col gap-6 px-4"
					method="POST"
					action={ urlb.EditorSave() }
					enctype="multipart/form-data"
				>
					@hiddenFields(props)
					@titleInput(props.Title)
					@markdownToggle(props.UseMarkdown)
					@contentTextarea(props.Content)
					@markdownPreview()
					if supportsAttachments(props.Type) {
						@attachmentsSeparator()
						@attachmentsSection(props.Attachments)
					}
					<br/>
					@formActions(props)
				</form>
			</div>
		</main>
		@uicomponents.MarkdownScript()
	}
}

templ pageNavContent(props *PageProps) {
	if props.ReturnURL != "" {
		@button.Button(button.Props{
			Variant: button.VariantSecondary,
			Href:    string(props.ReturnURL),
		}) {
			@icon.ArrowLeft()
			ZurÃ¼ck
		}
	}
}

templ pageAdditionalHead() {
	@uicomponents.MarkdownStyles()
	<script defer src={ ui.AssetURL(env.ServerPathPrefix, "/js/editor.js") }></script>
}

templ hiddenFields(options *PageProps) {
	<input type="hidden" id="type" name="type" value={ options.Type }/>
	<input type="hidden" id="id" name="id" value={ options.ID }/>
	<input type="hidden" id="return_url" name="return_url" value={ string(options.ReturnURL) }/>
	<input type="hidden" id="existing-attachments-removal" name="existing_attachments_removal" value=""/>
}

templ titleInput(title string) {
	@form.Item() {
		@form.Label(form.LabelProps{
			For: "title",
		}) {
			Titel	
		}
		@input.Input(input.Props{
			ID:          "title",
			Class:       "w-full",
			Name:        "title",
			Type:        input.TypeText,
			Placeholder: "Titel eingeben...",
			Value:       title,
			Attributes: templ.Attributes{
				"required": true,
			},
		})
	}
}

templ markdownToggle(useMarkdown bool) {
	@form.ItemFlex(form.ItemProps{
		Class: "p-4 text-muted-foreground bg-muted rounded border transition",
	}) {
		@checkbox.Checkbox(checkbox.Props{
			ID:      "use_markdown",
			Name:    "use_markdown",
			Checked: useMarkdown,
			Attributes: templ.Attributes{
				"onchange": "toggleMarkdownFeatures()",
			},
		})
		@form.Label(form.LabelProps{
			Class: "cursor-pointer",
			For:   "use_markdown",
		}) {
			Markdown-Formatierung verwenden
		}
	}
}

templ contentTextarea(content string) {
	@form.Item() {
		@form.Label(form.LabelProps{
			For: "content",
		}) {
			Inhalt
		}
		@textarea.Textarea(textarea.Props{
			ID:          "content",
			Class:       "w-full",
			Name:        "content",
			Placeholder: "Inhalt eingeben...",
			Value:       content,
			Rows:        15,
			AutoResize:  false,
			Attributes: templ.Attributes{
				"required": true,
			},
		})
	}
}

templ markdownPreview() {
	<div id="markdown-preview-container" class="hidden">
		<div
			id="markdown-preview"
			class="border flex flex-col overfow-hidden h-auto max-h-150 rounded"
		>
			<div class="p-2 border-b bg-muted text-muted-foreground font-semibold text-sm">
				<span>Live-Vorschau</span>
			</div>
			<div id="preview-content" class="markdown-content p flex-1 overflow-y-auto"></div>
		</div>
	</div>
}

templ attachmentsSeparator() {
	<div class={ css.MYLg, css.Relative, css.Flex, css.ItemsCenter, css.JustifyCenter }>
		<hr class={ css.WFull }/>
		<div class={ css.Absolute, css.PX, css.TextLG } style={ fmt.Sprintf("background: %s;", css.VarBg) }>ðŸ“Ž</div>
	</div>
}

templ attachmentsSection(attachments []string) {
	<div
		class={ css.Border, css.PLg, css.Muted, css.MT, css.TransitionAll }
		style={ fmt.Sprintf("border-radius: %s;", css.VarRadius) }
	>
		@attachmentsSectionHeader()
		if len(attachments) > 0 {
			@existingAttachments(attachments)
		}
		@fileUploadArea()
		@filePreviewArea()
	</div>
}

templ attachmentsSectionHeader() {
	<div class={ css.MB }>
		<h3
			class={ css.TextLG, css.TextSemibold, css.Primary, css.Ghost, css.Flex, css.GapSm, css.ItemsCenter, css.MB }
		>
			<i class="bi bi-paperclip"></i>
			Dateien & AnhÃ¤nge
		</h3>
		<div
			class={ css.P, css.BorderLeft, css.Primary, css.TextSM, css.TextMedium, css.Muted }
			style="border-left-width: 4px;"
		>
			Bilder (max. 10MB pro Datei, max. 10 Dateien)
		</div>
	</div>
}

templ existingAttachments(attachments []string) {
	<details class={ css.Border, css.MB } style={ fmt.Sprintf("border-radius: %s;", css.VarRadius) }>
		<summary class={ css.P, css.CursorPointer, css.TextMedium, css.Flex, css.Gap, css.ItemsCenter }>
			<i class="bi bi-images"></i>
			Vorhandene Bilder ({ len(attachments) })
		</summary>
		<div id="existing-attachments" class={ css.Flex, css.FlexCol, css.Gap, css.MT }>
			for attachmentIndex, attachment := range attachments {
				@existingAttachmentItem(attachment, attachmentIndex+1)
			}
		</div>
	</details>
}

templ existingAttachmentItem(attachment string, index int) {
	<div
		class={ css.P, css.Border, css.Flex, css.Gap, css.JustifyBetween, css.ItemsCenter }
		data-attachment-path={ attachment }
		style={ fmt.Sprintf("border-radius: %s", css.VarRadius) }
	>
		<div class={ css.Flex, css.Gap, css.ItemsCenter }>
			<span class={ css.TextMedium }>Anhang { index }</span>
			<span class={ css.Muted, css.TextSM }>({ attachment })</span>
		</div>
		<div class={ css.Flex, css.GapSm }>
			<button
				type="button"
				class={ css.Secondary, css.ButtonSmall }
				onclick={ components.OpenImageViewer(urlb.Attachment(attachment)) }
			>
				<i class="bi bi-eye"></i>
				Anzeigen
			</button>
			<button
				type="button"
				class={ css.Destructive, css.ButtonSmall }
				onclick={ deleteAttachment(attachment) }
			>
				<i class="bi bi-trash"></i>
				LÃ¶schen
			</button>
		</div>
	</div>
}

templ fileUploadArea() {
	<div
		class={ css.Border, css.PXl, css.TextCenter, css.CursorPointer, css.TransitionAll, css.MB }
		onclick='document.getElementById("attachments").click();'
		ondrop="handleFileDrop(event)"
		ondragover="handleDragOver(event)"
		ondragleave="handleDragLeave(event)"
		style={ fmt.Sprintf("border-radius: %s;", css.VarRadius) }
	>
		<i class={ "bi", "bi-cloud-upload", css.Text2XL, css.MB }></i>
		<div class={ css.TextMedium, css.MB }>Bilder hochladen</div>
		<div class={ css.TextSM, css.Opacity75 }>Klicken oder Dateien hierher ziehen</div>
		<input
			type="file"
			name="attachments"
			id="attachments"
			multiple
			accept="image/*"
			onchange="onAttachments(event)"
			class={ css.Hidden }
		/>
	</div>
}

templ filePreviewArea() {
	<div
		id="file-preview"
		class={ css.Border, css.P }
		style={ fmt.Sprintf("display: none; border-radius: %s", css.VarRadius) }
	>
		<div class={ css.MB, css.TextMedium }>
			<span>Neue Bilder:</span>
		</div>
		<div id="new-attachments" class={ css.Flex, css.FlexCol, css.Gap }></div>
		<template name="attachment-item">
			<div
				class={ css.P, css.Border, css.Flex, css.Gap, css.JustifyBetween, css.ItemsCenter }
				style={ fmt.Sprintf("border-radius: %s", css.VarRadius) }
			>
				<div class={ css.Flex, css.Gap, css.ItemsCenter }>
					<span class={ "attachment-name", "name", css.TextMedium }></span>
					<span class={ "attachment-size", "size-text", css.TextSM, css.Muted }></span>
				</div>
				<div>
					<button type="button" class={ css.Destructive, css.ButtonSmall, css.Flex, css.Gap }>
						<i class="bi bi-trash"></i>
						Entfernen
					</button>
				</div>
			</div>
		</template>
	</div>
}

templ formActions(options *PageProps) {
	<div class={ css.MT, css.PT, css.BorderTop, css.Flex, css.Gap, css.JustifyEnd }>
		<button type="submit" class={ css.Primary, css.Flex, css.GapSm, css.ItemsCenter }>
			if options.ID > 0 {
				<i class="bi bi-check-circle"></i>
				Aktualisieren
			} else {
				<i class="bi bi-plus-circle"></i>
				Erstellen
			}
		</button>
	</div>
}

func getTypeName(editorType shared.EditorType) string {
	switch editorType {
	case shared.EditorTypeTroubleReport:
		return "Problembericht"
	default:
		return "Dokument"
	}
}

func supportsAttachments(editorType shared.EditorType) bool {
	return editorType == shared.EditorTypeTroubleReport
}

script deleteAttachment(attachment string) {
	deleteAttachment(attachment);
}
