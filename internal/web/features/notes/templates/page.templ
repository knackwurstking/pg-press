package templates

// Notes Management Implementation:
//
// This page provides comprehensive notes management for the PG Press system:
// - Create, edit, and delete notes with priority levels (INFO, ATTENTION, BROKEN)
// - Link notes to specific entities using generic "linked" field
// - Filter notes by priority level with live JavaScript filtering
// - Display linked entities with direct links where applicable
// - Automatic sorting: BROKEN notes first, then ATTENTION, then INFO, newest first
// - Real-time updates via HTMX triggers after note operations
//
// Notes can be linked to any entity using the format "type_id":
// - Individual tools: "tool_123" - note appears only for that tool
// - Entire presses: "press_5" - note is specific to that press
// - Or any other entity type as needed
//
// The linking system uses a simple string field for maximum flexibility.

import (
	"fmt"

	"github.com/knackwurstking/pgpress/internal/web/shared/components"
	"github.com/knackwurstking/pgpress/internal/web/shared/layouts"
	"github.com/knackwurstking/pgpress/pkg/models"
)

type PageProps struct {
	Notes []*models.Note
	Tools []*models.Tool
}

templ Page(props *PageProps) {
	@layouts.Main(
		layouts.MainOptions{
			PageTitle:   "PG Presse | Notizen Verwaltung",
			AppBarTitle: "Notizen Verwaltung",
			NavContent:  navContent(),
		},
	) {
		<main class="container fluid">
			<!-- Filter Section -->
			<section class="filter-section mb">
				<div class="flex gap-sm justify-center items-center w-full flex-wrap">
					<button class="filter-btn active small" data-filter="all">
						Alle ({ fmt.Sprintf("%d", len(props.Notes)) })
					</button>
					{{ brokenCount := 0 }}
					{{ attentionCount := 0 }}
					{{ infoCount := 0 }}
					{{
						outer:
						for _, note := range props.Notes {
							l := note.GetLinked()
							if l.Name == "tool" {
								for _, t := range props.Tools {
									if t.ID == l.ID && t.IsDead {
										continue outer
									}
								}
							}

							switch note.Level {
							case models.BROKEN:
								brokenCount++
							case models.ATTENTION:
								attentionCount++
							case models.INFO:
								infoCount++
							}
						}
					}}
					<button class="filter-btn small destructive flex gap-sm" data-filter="broken">
						<i class="bi bi-x-circle text-danger"></i>
						Defekt ({ fmt.Sprintf("%d", brokenCount) })
					</button>
					<button class="filter-btn small warning flex gap-sm" data-filter="attention">
						<i class="bi bi-exclamation-triangle text-warning"></i>
						Achtung ({ fmt.Sprintf("%d", attentionCount) })
					</button>
					<button class="filter-btn small info flex gap-sm" data-filter="info">
						<i class="bi bi-info-circle"></i>
						Info ({ fmt.Sprintf("%d", infoCount) })
					</button>
				</div>
			</section>
			<!-- Notes List -->
			<section class="notes-grid max-w-full" style="margin: 0 auto;">
				@NotesGrid(props.Notes, props.Tools)
			</section>
		</main>
		<!-- JavaScript for filtering -->
		@pageScript()
	}
}

templ navContent() {
	@components.NavFeedButton()
	@components.NavProfileButton()
	@components.NavHomeButton()
}

script pageScript() {
	document.addEventListener('DOMContentLoaded', function() {
		const filterButtons = document.querySelectorAll('.filter-btn');
		const noteCards = document.querySelectorAll('.note-card');

		filterButtons.forEach(button => {
			button.addEventListener('click', function() {
				const filter = this.dataset.filter;

				// Update active button
				filterButtons.forEach(btn => btn.classList.remove('active'));
				this.classList.add('active');

				// Show/hide cards based on filter
				noteCards.forEach(card => {
					const level = card.dataset.noteLevel;
					const shouldShow = filter === 'all' ||
						(filter === 'broken' && level === '2') ||
						(filter === 'attention' && level === '1') ||
						(filter === 'info' && level === '0');

					if (shouldShow) {
						card.style.display = 'block';
					} else {
						card.style.display = 'none';
					}
				});
			});
		});
	});
}
