package templates

// Notes Management Implementation:
//
// This page provides comprehensive notes management for the PG Press system:
// - Create, edit, and delete notes with priority levels (INFO, ATTENTION, BROKEN)
// - Link notes to specific entities using generic "linked" field
// - Filter notes by priority level with live JavaScript filtering
// - Display linked entities with direct links where applicable
// - Automatic sorting: BROKEN notes first, then ATTENTION, then INFO, newest first
// - Real-time updates via HTMX triggers after note operations
//
// Notes can be linked to any entity using the format "type_id":
// - Individual tools: "tool_123" - note appears only for that tool
// - Entire presses: "press_5" - note is specific to that press
// - Or any other entity type as needed
//
// The linking system uses a simple string field for maximum flexibility.

import (
	"fmt"
	"sort"
	"strconv"
	"strings"

	"github.com/knackwurstking/pgpress/internal/env"
	"github.com/knackwurstking/pgpress/internal/web/shared/components"
	"github.com/knackwurstking/pgpress/internal/web/shared/layouts"
	"github.com/knackwurstking/pgpress/pkg/models"
)

type PageProps struct {
	User  *models.User
	Notes []*models.Note
	Tools []*models.Tool
}

templ Page(props *PageProps) {
	{{ sortedNotes := make([]*models.Note, len(props.Notes)) }}
	{{ copy(sortedNotes, props.Notes) }}
	{{
		sort.Slice(sortedNotes, func(i, j int) bool {
			// Sort by level (BROKEN first, then ATTENTION, then INFO), then by creation date (newest first)
			if sortedNotes[i].Level != sortedNotes[j].Level {
				return sortedNotes[i].Level > sortedNotes[j].Level
			}
			return sortedNotes[i].CreatedAt.After(sortedNotes[j].CreatedAt)
		})
	}}
	@layouts.Main(
		layouts.MainOptions{
			PageTitle:   "PG Presse | Notizen Verwaltung",
			AppBarTitle: "Notizen Verwaltung",
			NavContent:  navContent(),
		},
	) {
		<main class="container fluid">
			<!-- Actions Section -->
			<section class="flex justify-between items-center mb">
				<h2>Alle Notizen ({ fmt.Sprintf("%d", len(sortedNotes)) })</h2>
			</section>
			<!-- Filter Section -->
			<section class="filter-section mb">
				<div class="flex gap justify-center items-center">
					<button class="filter-btn active small" data-filter="all">
						Alle ({ fmt.Sprintf("%d", len(sortedNotes)) })
					</button>
					{{ brokenCount := 0 }}
					{{ attentionCount := 0 }}
					{{ infoCount := 0 }}
					{{
						for _, note := range sortedNotes {
							switch note.Level {
							case models.BROKEN:
								brokenCount++
							case models.ATTENTION:
								attentionCount++
							case models.INFO:
								infoCount++
							}
						}
					}}
					<button class="filter-btn small destructive flex gap-sm" data-filter="broken">
						<i class="bi bi-x-circle text-danger"></i>
						Defekt ({ fmt.Sprintf("%d", brokenCount) })
					</button>
					<button class="filter-btn small warning flex gap-sm" data-filter="attention">
						<i class="bi bi-exclamation-triangle text-warning"></i>
						Achtung ({ fmt.Sprintf("%d", attentionCount) })
					</button>
					<button class="filter-btn small info flex gap-sm" data-filter="info">
						<i class="bi bi-info-circle"></i>
						Info ({ fmt.Sprintf("%d", infoCount) })
					</button>
				</div>
			</section>
			<!-- Notes List -->
			<section class="notes-grid">
				if len(sortedNotes) > 0 {
					<div class="notes-list">
						for _, note := range sortedNotes {
							{{ filterClass := "info" }}
							{{
								switch note.Level {
								case models.BROKEN:
									filterClass = "broken"
								case models.ATTENTION:
									filterClass = "attention"
								case models.INFO:
									filterClass = "info"
								}
							}}
							<div
								class={ fmt.Sprintf("note-card card %s", filterClass) }
								data-note-level={ fmt.Sprintf("%d", note.Level) }
							>
								<div class="card-header">
									<div class="note-importance">
										switch note.Level {
											case models.INFO:
												<i class="bi bi-info-circle"></i>
												<span>Info</span>
											case models.ATTENTION:
												<i class="bi bi-exclamation-triangle text-warning"></i>
												<strong>Achtung</strong>
											case models.BROKEN:
												<i class="bi bi-x-circle text-danger"></i>
												<strong>Defekt</strong>
										}
									</div>
									<div class="note-actions flex gap-sm justify-between items-center">
										<span class="note-date text-sm text-muted">
											{ note.CreatedAt.Format("2006-01-02 15:04") }
										</span>
										<span>
											<button
												class="icon small secondary"
												hx-get={ fmt.Sprintf(
												"%s/htmx/notes/edit?id=%d&link_to_tables=%s",
												env.ServerPathPrefix, note.ID, note.Linked,
											) }
												hx-trigger="click"
												hx-target="body"
												hx-swap="beforeend"
												hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
												title="Notiz bearbeiten"
											>
												<i class="bi bi-pencil"></i>
											</button>
											<button
												class="icon small destructive"
												hx-delete={ fmt.Sprintf(
												"%s/htmx/notes/delete?id=%d",
												env.ServerPathPrefix, note.ID,
											) }
												hx-trigger="click"
												hx-confirm="Sind Sie sicher, dass Sie diese Notiz löschen möchten?"
												hx-on:htmx:response-error="alert(event.detail.xhr.responseText)"
												title="Notiz löschen"
											>
												<i class="bi bi-trash"></i>
											</button>
										</span>
									</div>
								</div>
								<div class="card-body">
									<p class="note-content">{ note.Content }</p>
									if note.Linked != "" {
										<div class="linked-info mt-sm">
											<small class="text-muted">
												<strong>Verknüpft mit:</strong>
												if strings.HasPrefix(note.Linked, "tool_") {
													{{ toolIDStr := strings.TrimPrefix(note.Linked, "tool_") }}
													{{ toolID, _ := strconv.ParseInt(toolIDStr, 10, 64) }}
													for _, tool := range props.Tools {
														if tool.ID == toolID {
															<a
																href={ fmt.Sprintf("%s/tools/tool/%d", env.ServerPathPrefix, tool.ID) }
																class="tool-link"
															>
																{ fmt.Sprintf("Werkzeug %s %s", tool.Format.String(), tool.Code) }
																if tool.Press != nil {
																	({ fmt.Sprintf("Presse %d", *tool.Press) })
																}
															</a>
														}
													}
												} else if strings.HasPrefix(note.Linked, "press_") {
													{{ pressIDStr := strings.TrimPrefix(note.Linked, "press_") }}
													<a
														href={ fmt.Sprintf("%s/tools/press/%s", env.ServerPathPrefix, pressIDStr) }
														class="press-link"
													>
														{ fmt.Sprintf("Presse %s", pressIDStr) }
													</a>
												} else {
													<span>{ note.Linked }</span>
												}
											</small>
										</div>
									}
								</div>
							</div>
						}
					</div>
				} else {
					<div class="empty-state text-center">
						<i class="bi bi-clipboard-x display-4 text-muted"></i>
						<h3>Keine Notizen vorhanden</h3>
						<p class="text-muted">Notizen können über die jeweiligen Werkzeug- oder Pressenseiten erstellt werden.</p>
					</div>
				}
			</section>
		</main>
		<!-- JavaScript for filtering -->
		<script>
			document.addEventListener('DOMContentLoaded', function() {
				const filterButtons = document.querySelectorAll('.filter-btn');
				const noteCards = document.querySelectorAll('.note-card');

				filterButtons.forEach(button => {
					button.addEventListener('click', function() {
						const filter = this.dataset.filter;

						// Update active button
						filterButtons.forEach(btn => btn.classList.remove('active'));
						this.classList.add('active');

						// Show/hide cards based on filter
						noteCards.forEach(card => {
							const level = card.dataset.noteLevel;
							const shouldShow = filter === 'all' ||
								(filter === 'broken' && level === '2') ||
								(filter === 'attention' && level === '1') ||
								(filter === 'info' && level === '0');

							if (shouldShow) {
								card.style.display = 'block';
							} else {
								card.style.display = 'none';
							}
						});
					});
				});
			});
		</script>
		<!-- CSS for notes page -->
		<style>
			.notes-grid {
				max-width: 100%;
				margin: 0 auto;
			}

			.notes-list {
				display: flex;
				flex-wrap: wrap;
				gap: 1rem;
				justify-content: flex-start;
			}

			.note-card {
				border-left: 4px solid;
				transition: all 0.2s ease;
				width: fit-content;
				max-width: 500px;
			}

			.note-card.broken {
				border-left-color: var(--color-danger, #dc3545);
			}

			.note-card.attention {
				border-left-color: var(--color-warning, #ffc107);
			}

			.note-card.info {
				border-left-color: var(--color-info, #0dcaf0);
			}

			.note-card:hover {
				transform: translateY(-2px);
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
			}

			.note-importance {
				display: flex;
				align-items: center;
				gap: 0.5rem;
			}

			.note-actions {
				display: flex;
				align-items: center;
			}

			.linked-info .tool-link,
			.linked-info .press-link {
				color: var(--primary-color, #0d6efd);
				text-decoration: none;
			}

			.linked-info .tool-link:hover {
				text-decoration: underline;
			}

			.empty-state {
				padding: 3rem 1rem;
			}

			.note-content {
				white-space: pre-wrap;
				word-wrap: break-word;
			}
		</style>
	}
}

templ navContent() {
	<div class="flex flex-row gap justify-end items-center">
		@components.NavFeedButton()
		@components.NavProfileButton()
		@components.NavHomeButton()
	</div>
}
